<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pymatgen.analysis package &#8212; pymatgen 4.2.1 documentation</title>
    
    <link rel="stylesheet" href="_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '4.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="top" title="pymatgen 4.2.1 documentation" href="index.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pymatgen 4.2.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="pymatgen-analysis-package">
<h1>pymatgen.analysis package<a class="headerlink" href="#pymatgen-analysis-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pymatgen.analysis.chemenv.html">pymatgen.analysis.chemenv package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.chemenv.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html">pymatgen.analysis.chemenv.coordination_environments package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html#subpackages">Subpackages</a><ul>
<li class="toctree-l5"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.coordination_geometries_files.html">pymatgen.analysis.chemenv.coordination_environments.coordination_geometries_files package</a><ul>
<li class="toctree-l6"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.coordination_geometries_files.html#module-pymatgen.analysis.chemenv.coordination_environments.coordination_geometries_files">Module contents</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.strategy_files.html">pymatgen.analysis.chemenv.coordination_environments.strategy_files package</a><ul>
<li class="toctree-l6"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.strategy_files.html#module-pymatgen.analysis.chemenv.coordination_environments.strategy_files">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html#pymatgen-analysis-chemenv-coordination-environments-chemenv-strategies-module">pymatgen.analysis.chemenv.coordination_environments.chemenv_strategies module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html#module-pymatgen.analysis.chemenv.coordination_environments.coordination_geometries">pymatgen.analysis.chemenv.coordination_environments.coordination_geometries module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html#pymatgen-analysis-chemenv-coordination-environments-coordination-geometry-finder-module">pymatgen.analysis.chemenv.coordination_environments.coordination_geometry_finder module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html#pymatgen-analysis-chemenv-coordination-environments-structure-environments-module">pymatgen.analysis.chemenv.coordination_environments.structure_environments module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html#pymatgen-analysis-chemenv-coordination-environments-voronoi-module">pymatgen.analysis.chemenv.coordination_environments.voronoi module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.coordination_environments.html#module-pymatgen.analysis.chemenv.coordination_environments">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html">pymatgen.analysis.chemenv.utils package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#subpackages">Subpackages</a><ul class="simple">
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#pymatgen-analysis-chemenv-utils-chemenv-config-module">pymatgen.analysis.chemenv.utils.chemenv_config module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#module-pymatgen.analysis.chemenv.utils.chemenv_errors">pymatgen.analysis.chemenv.utils.chemenv_errors module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#module-pymatgen.analysis.chemenv.utils.coordination_geometry_utils">pymatgen.analysis.chemenv.utils.coordination_geometry_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#module-pymatgen.analysis.chemenv.utils.defs_utils">pymatgen.analysis.chemenv.utils.defs_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#module-pymatgen.analysis.chemenv.utils.func_utils">pymatgen.analysis.chemenv.utils.func_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#module-pymatgen.analysis.chemenv.utils.math_utils">pymatgen.analysis.chemenv.utils.math_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#pymatgen-analysis-chemenv-utils-scripts-utils-module">pymatgen.analysis.chemenv.utils.scripts_utils module</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.chemenv.utils.html#module-pymatgen.analysis.chemenv.utils">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.chemenv.html#module-pymatgen.analysis.chemenv">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pymatgen.analysis.cost.html">pymatgen.analysis.cost package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.cost.html#subpackages">Subpackages</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.cost.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.cost.html#module-pymatgen.analysis.cost.cost">pymatgen.analysis.cost.cost module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.cost.html#module-pymatgen.analysis.cost">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pymatgen.analysis.defects.html">pymatgen.analysis.defects package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.defects.html#subpackages">Subpackages</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.defects.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.defects.html#module-pymatgen.analysis.defects.dilute_solution_model">pymatgen.analysis.defects.dilute_solution_model module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.defects.html#module-pymatgen.analysis.defects.point_defects">pymatgen.analysis.defects.point_defects module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.defects.html#module-pymatgen.analysis.defects.surf_error">pymatgen.analysis.defects.surf_error module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.defects.html#module-pymatgen.analysis.defects">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pymatgen.analysis.diffraction.html">pymatgen.analysis.diffraction package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.diffraction.html#subpackages">Subpackages</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.diffraction.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.diffraction.html#module-pymatgen.analysis.diffraction.xrd">pymatgen.analysis.diffraction.xrd module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.diffraction.html#module-pymatgen.analysis.diffraction">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pymatgen.analysis.elasticity.html">pymatgen.analysis.elasticity package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.elasticity.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.elasticity.html#module-pymatgen.analysis.elasticity.elastic">pymatgen.analysis.elasticity.elastic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.elasticity.html#module-pymatgen.analysis.elasticity.strain">pymatgen.analysis.elasticity.strain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.elasticity.html#module-pymatgen.analysis.elasticity.stress">pymatgen.analysis.elasticity.stress module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.elasticity.html#module-pymatgen.analysis.elasticity.tensors">pymatgen.analysis.elasticity.tensors module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.elasticity.html#module-pymatgen.analysis.elasticity">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pymatgen.analysis.hhi.html">pymatgen.analysis.hhi package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.hhi.html#subpackages">Subpackages</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.hhi.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.hhi.html#module-pymatgen.analysis.hhi.hhi">pymatgen.analysis.hhi.hhi module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.hhi.html#module-pymatgen.analysis.hhi">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pymatgen.analysis.pourbaix.html">pymatgen.analysis.pourbaix package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.pourbaix.html#subpackages">Subpackages</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.pourbaix.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.pourbaix.html#pymatgen-analysis-pourbaix-analyzer-module">pymatgen.analysis.pourbaix.analyzer module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.pourbaix.html#module-pymatgen.analysis.pourbaix.entry">pymatgen.analysis.pourbaix.entry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.pourbaix.html#pymatgen-analysis-pourbaix-maker-module">pymatgen.analysis.pourbaix.maker module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.pourbaix.html#pymatgen-analysis-pourbaix-plotter-module">pymatgen.analysis.pourbaix.plotter module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymatgen.analysis.pourbaix.html#module-pymatgen.analysis.pourbaix">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pymatgen.analysis.bond_valence">
<span id="pymatgen-analysis-bond-valence-module"></span><h2>pymatgen.analysis.bond_valence module<a class="headerlink" href="#module-pymatgen.analysis.bond_valence" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.bond_valence.BVAnalyzer">
<em class="property">class </em><code class="descname">BVAnalyzer</code><span class="sig-paren">(</span><em>symm_tol=0.1</em>, <em>max_radius=4</em>, <em>max_permutations=100000</em>, <em>distance_scale_factor=1.015</em>, <em>charge_neutrality_tolerance=1e-05</em>, <em>forbidden_species=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/bond_valence.html#BVAnalyzer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.bond_valence.BVAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class implements a maximum a posteriori (MAP) estimation method to
determine oxidation states in a structure. The algorithm is as follows:
1) The bond valence sum of all symmetrically distinct sites in a structure
is calculated using the element-based parameters in M. O&#8217;Keefe, &amp; N. Brese,
JACS, 1991, 113(9), 3226-3229. doi:10.1021/ja00009a002.
2) The posterior probabilities of all oxidation states is then calculated
using: P(oxi_state/BV) = K * P(BV/oxi_state) * P(oxi_state), where K is
a constant factor for each element. P(BV/oxi_state) is calculated as a
Gaussian with mean and std deviation determined from an analysis of
the ICSD. The posterior P(oxi_state) is determined from a frequency
analysis of the ICSD.
3) The oxidation states are then ranked in order of decreasing probability
and the oxidation state combination that result in a charge neutral cell
is selected.</p>
<p>Initializes the BV analyzer, with useful defaults.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>symm_tol</strong> &#8211; Symmetry tolerance used to determine which sites are
symmetrically equivalent. Set to 0 to turn off symmetry.</li>
<li><strong>max_radius</strong> &#8211; Maximum radius in Angstrom used to find nearest neighbors.</li>
<li><strong>max_permutations</strong> &#8211; The maximum number of permutations of oxidation states to test.</li>
<li><strong>distance_scale_factor</strong> &#8211; A scale factor to be applied. This is useful for scaling
distances, esp in the case of calculation-relaxed structures
which may tend to under (GGA) or over bind (LDA). The default
of 1.015 works for GGA. For experimental structure, set this to
1.</li>
<li><strong>charge_neutrality_tolerance</strong> &#8211; Tolerance on the charge neutrality when unordered structures
are at stake.</li>
<li><strong>forbidden_species</strong> &#8211; List of species that are forbidden (example : [&#8220;O-&#8220;] cannot be
used) It is used when e.g. someone knows that some oxidation
state cannot occur for some atom in a structure or list of
structures.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pymatgen.analysis.bond_valence.BVAnalyzer.CHARGE_NEUTRALITY_TOLERANCE">
<code class="descname">CHARGE_NEUTRALITY_TOLERANCE</code><em class="property"> = 1e-05</em><a class="headerlink" href="#pymatgen.analysis.bond_valence.BVAnalyzer.CHARGE_NEUTRALITY_TOLERANCE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.bond_valence.BVAnalyzer.get_oxi_state_decorated_structure">
<code class="descname">get_oxi_state_decorated_structure</code><span class="sig-paren">(</span><em>structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/bond_valence.html#BVAnalyzer.get_oxi_state_decorated_structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.bond_valence.BVAnalyzer.get_oxi_state_decorated_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an oxidation state decorated structure. This currently works only
for ordered structures only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>structure</strong> &#8211; Structure to analyze</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A modified structure that is oxidation state decorated.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">ValueError if the valences cannot be determined.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.bond_valence.BVAnalyzer.get_valences">
<code class="descname">get_valences</code><span class="sig-paren">(</span><em>structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/bond_valence.html#BVAnalyzer.get_valences"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.bond_valence.BVAnalyzer.get_valences" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of valences for the structure. This currently works only
for ordered structures only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>structure</strong> &#8211; Structure to analyze</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of valences for each site in the structure (for an ordered
structure), e.g., [1, 1, -2] or a list of lists with the
valences for each fractional element of each site in the
structure (for an unordered structure),
e.g., [[2, 4], [3], [-2], [-2], [-2]]</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">A ValueError if the valences cannot be determined.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.bond_valence.add_oxidation_state_by_site_fraction">
<code class="descname">add_oxidation_state_by_site_fraction</code><span class="sig-paren">(</span><em>structure</em>, <em>oxidation_states</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/bond_valence.html#add_oxidation_state_by_site_fraction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.bond_valence.add_oxidation_state_by_site_fraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Add oxidation states to a structure by fractional site.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>oxidation_states</strong> (<em>list</em>) &#8211; List of list of oxidation states for each
site fraction for each site.
E.g., [[2, 4], [3], [-2], [-2], [-2]]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.bond_valence.calculate_bv_sum">
<code class="descname">calculate_bv_sum</code><span class="sig-paren">(</span><em>site</em>, <em>nn_list</em>, <em>scale_factor=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/bond_valence.html#calculate_bv_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.bond_valence.calculate_bv_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the BV sum of a site.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>site</strong> &#8211; The site</li>
<li><strong>nn_list</strong> &#8211; List of nearest neighbors in the format [(nn_site, dist), ...].</li>
<li><strong>anion_el</strong> &#8211; The most electronegative element in the structure.</li>
<li><strong>scale_factor</strong> &#8211; A scale factor to be applied. This is useful for scaling distance,
esp in the case of calculation-relaxed structures which may tend
to under (GGA) or over bind (LDA).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.bond_valence.calculate_bv_sum_unordered">
<code class="descname">calculate_bv_sum_unordered</code><span class="sig-paren">(</span><em>site</em>, <em>nn_list</em>, <em>scale_factor=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/bond_valence.html#calculate_bv_sum_unordered"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.bond_valence.calculate_bv_sum_unordered" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the BV sum of a site for unordered structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>site</strong> &#8211; The site</li>
<li><strong>nn_list</strong> &#8211; List of nearest neighbors in the format [(nn_site, dist), ...].</li>
<li><strong>anion_el</strong> &#8211; The most electronegative element in the structure.</li>
<li><strong>scale_factor</strong> &#8211; A scale factor to be applied. This is useful for scaling distance,
esp in the case of calculation-relaxed structures which may tend
to under (GGA) or over bind (LDA).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.bond_valence.get_z_ordered_elmap">
<code class="descname">get_z_ordered_elmap</code><span class="sig-paren">(</span><em>comp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/bond_valence.html#get_z_ordered_elmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.bond_valence.get_z_ordered_elmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Arbitrary ordered elmap on the elements/species of a composition of a
given site in an unordered structure. Returns a list of tuples (
element_or_specie: occupation) in the arbitrary order.</p>
<p>The arbitrary order is based on the Z of the element and the smallest
fractional occupations first.
Example : {&#8220;Ni3+&#8221;: 0.2, &#8220;Ni4+&#8221;: 0.2, &#8220;Cr3+&#8221;: 0.15, &#8220;Zn2+&#8221;: 0.34,
&#8220;Cr4+&#8221;: 0.11} will yield the species in the following order :
Cr4+, Cr3+, Ni3+, Ni4+, Zn2+ ... or
Cr4+, Cr3+, Ni4+, Ni3+, Zn2+</p>
</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.diffusion_analyzer">
<span id="pymatgen-analysis-diffusion-analyzer-module"></span><h2>pymatgen.analysis.diffusion_analyzer module<a class="headerlink" href="#module-pymatgen.analysis.diffusion_analyzer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer">
<em class="property">class </em><code class="descname">DiffusionAnalyzer</code><span class="sig-paren">(</span><em>structure</em>, <em>displacements</em>, <em>specie</em>, <em>temperature</em>, <em>time_step</em>, <em>step_skip</em>, <em>smoothed='max'</em>, <em>min_obs=30</em>, <em>avg_nsteps=1000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>Class for performing diffusion analysis.</p>
<p>This constructor is meant to be used with pre-processed data.
Other convenient constructors are provided as class methods (see
from_vaspruns and from_files).</p>
<p>Given a matrix of displacements (see arguments below for expected
format), the diffusivity is given by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">D</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="n">dt</span> <span class="o">*</span> <span class="o">&lt;</span><span class="n">mean</span> <span class="n">square</span> <span class="n">displacement</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>where d is the dimensionality, t is the time. To obtain a reliable
diffusion estimate, a least squares regression of the MSD against
time to obtain the slope, which is then related to the diffusivity.</p>
<p>For traditional analysis, use smoothed=False and weighted=False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Initial structure.</li>
<li><strong>displacements</strong> (<em>array</em>) &#8211; Numpy array of with shape [site,
time step, axis]</li>
<li><strong>specie</strong> (<em>Element/Specie</em>) &#8211; Specie to calculate diffusivity for as a
String. E.g., &#8220;Li&#8221;.</li>
<li><strong>temperature</strong> (<em>float</em>) &#8211; Temperature of the diffusion run in Kelvin.</li>
<li><strong>time_step</strong> (<em>int</em>) &#8211; Time step between measurements.</li>
<li><strong>step_skip</strong> (<em>int</em>) &#8211; Sampling frequency of the displacements (
time_step is multiplied by this number to get the real time
between measurements)</li>
<li><strong>smoothed</strong> (<em>str</em>) &#8211; <p>Whether to smooth the MSD, and what mode to smooth.
Supported modes are:</p>
<ol class="lowerroman">
<li>&#8220;max&#8221;, which tries to use the maximum #
of data points for each time origin, subject to a
minimum # of observations given by min_obs, and then
weights the observations based on the variance
accordingly. This is the default.</li>
<li>&#8220;constant&#8221;, in which each timestep is averaged over
the number of time_steps given by min_steps.</li>
<li>None / False / any other false-like quantity. No</li>
</ol>
<blockquote>
<div>smoothing.</div></blockquote>
</li>
<li><strong>min_obs</strong> (<em>int</em>) &#8211; Used with smoothed=&#8221;max&#8221;. Minimum number of
observations to have before including in the MSD vs dt
calculation. E.g. If a structure has 10 diffusing atoms,
and min_obs = 30, the MSD vs dt will be
calculated up to dt = total_run_time / 3, so that each
diffusing atom is measured at least 3 uncorrelated times.
Only applies in smoothed=&#8221;max&#8221;.</li>
<li><strong>avg_nsteps</strong> (<em>int</em>) &#8211; Used with smoothed=&#8221;constant&#8221;. Determines the
number of time steps to average over to get the msd for each
timestep. Default of 1000 is usually pretty good.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.export_msdt">
<code class="descname">export_msdt</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.export_msdt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.export_msdt" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes MSD data to a csv file that can be easily plotted in other
software.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> (<em>str</em>) &#8211; Filename. Supported formats are csv and dat. If
the extension is csv, a csv file is written. Otherwise,
a dat format is assumed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.from_files">
<em class="property">classmethod </em><code class="descname">from_files</code><span class="sig-paren">(</span><em>filepaths</em>, <em>specie</em>, <em>step_skip=10</em>, <em>smoothed='max'</em>, <em>min_obs=30</em>, <em>avg_nsteps=1000</em>, <em>ncores=None</em>, <em>initial_disp=None</em>, <em>initial_structure=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.from_files"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.from_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient constructor that takes in a list of vasprun.xml paths to
perform diffusion analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filepaths</strong> (<em>[str]</em>) &#8211; List of paths to vasprun.xml files of runs. (
must be ordered in sequence of MD simulation). For example,
you may have done sequential VASP runs and they are in run1,
run2, run3, etc. You should then pass in
[&#8220;run1/vasprun.xml&#8221;, &#8220;run2/vasprun.xml&#8221;, ...].</li>
<li><strong>specie</strong> (<em>Element/Specie</em>) &#8211; Specie to calculate diffusivity for as a
String. E.g., &#8220;Li&#8221;.</li>
<li><strong>step_skip</strong> (<em>int</em>) &#8211; Sampling frequency of the displacements (
time_step is multiplied by this number to get the real time
between measurements)</li>
<li><strong>smoothed</strong> (<em>str</em>) &#8211; <p>Whether to smooth the MSD, and what mode to smooth.
Supported modes are:</p>
<ol class="lowerroman">
<li>&#8220;max&#8221;, which tries to use the maximum #
of data points for each time origin, subject to a
minimum # of observations given by min_obs, and then
weights the observations based on the variance
accordingly. This is the default.</li>
<li>&#8220;constant&#8221;, in which each timestep is averaged over
the same number of observations given by min_obs.</li>
<li>None / False / any other false-like quantity. No</li>
</ol>
<blockquote>
<div>smoothing.</div></blockquote>
</li>
<li><strong>min_obs</strong> (<em>int</em>) &#8211; Used with smoothed=&#8221;max&#8221;. Minimum number of
observations to have before including in the MSD vs dt
calculation. E.g. If a structure has 10 diffusing atoms,
and min_obs = 30, the MSD vs dt will be
calculated up to dt = total_run_time / 3, so that each
diffusing atom is measured at least 3 uncorrelated times.
Only applies in smoothed=&#8221;max&#8221;.</li>
<li><strong>avg_nsteps</strong> (<em>int</em>) &#8211; Used with smoothed=&#8221;constant&#8221;. Determines the
number of time steps to average over to get the msd for each
timestep. Default of 1000 is usually pretty good.</li>
<li><strong>ncores</strong> (<em>int</em>) &#8211; Numbers of cores to use for multiprocessing. Can
speed up vasprun parsing considerably. Defaults to None,
which means serial. It should be noted that if you want to
use multiprocessing, the number of ionic steps in all vasprun
.xml files should be a multiple of the ionic_step_skip.
Otherwise, inconsistent results may arise. Serial mode has no
such restrictions.</li>
<li><strong>initial_disp</strong> (<em>np.ndarray</em>) &#8211; Sometimes, you need to iteratively
compute estimates of the diffusivity. This supplies an
initial displacement that will be added on to the initial
displacements. Note that this makes sense only when
smoothed=False.</li>
<li><strong>initial_structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Like initial_disp, this is used
for iterative computations of estimates of the diffusivity. You
typically need to supply both variables. This stipulates the
initial strcture from which the current set of displacements
are computed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.from_structures">
<em class="property">classmethod </em><code class="descname">from_structures</code><span class="sig-paren">(</span><em>structures</em>, <em>specie</em>, <em>temperature</em>, <em>time_step</em>, <em>step_skip</em>, <em>smoothed='max'</em>, <em>min_obs=30</em>, <em>avg_nsteps=1000</em>, <em>initial_disp=None</em>, <em>initial_structure=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.from_structures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.from_structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient constructor that takes in a list of Structure objects to
perform diffusion analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>structures</strong> (<em>[Structure]</em>) &#8211; list of Structure objects (must be
ordered in sequence of run). E.g., you may have performed
sequential VASP runs to obtain sufficient statistics.</li>
<li><strong>specie</strong> (<em>Element/Specie</em>) &#8211; Specie to calculate diffusivity for as a
String. E.g., &#8220;Li&#8221;.</li>
<li><strong>temperature</strong> (<em>float</em>) &#8211; Temperature of the diffusion run in Kelvin.</li>
<li><strong>time_step</strong> (<em>int</em>) &#8211; Time step between measurements.</li>
<li><strong>step_skip</strong> (<em>int</em>) &#8211; Sampling frequency of the displacements (
time_step is multiplied by this number to get the real time
between measurements)</li>
<li><strong>smoothed</strong> (<em>str</em>) &#8211; <p>Whether to smooth the MSD, and what mode to smooth.
Supported modes are:</p>
<ol class="lowerroman">
<li>&#8220;max&#8221;, which tries to use the maximum #
of data points for each time origin, subject to a
minimum # of observations given by min_obs, and then
weights the observations based on the variance
accordingly. This is the default.</li>
<li>&#8220;constant&#8221;, in which each timestep is averaged over
the same number of observations given by min_obs.</li>
<li>None / False / any other false-like quantity. No</li>
</ol>
<blockquote>
<div>smoothing.</div></blockquote>
</li>
<li><strong>min_obs</strong> (<em>int</em>) &#8211; Used with smoothed=&#8221;max&#8221;. Minimum number of
observations to have before including in the MSD vs dt
calculation. E.g. If a structure has 10 diffusing atoms,
and min_obs = 30, the MSD vs dt will be
calculated up to dt = total_run_time / 3, so that each
diffusing atom is measured at least 3 uncorrelated times.
Only applies in smoothed=&#8221;max&#8221;.</li>
<li><strong>avg_nsteps</strong> (<em>int</em>) &#8211; Used with smoothed=&#8221;constant&#8221;. Determines the
number of time steps to average over to get the msd for each
timestep. Default of 1000 is usually pretty good.</li>
<li><strong>initial_disp</strong> (<em>np.ndarray</em>) &#8211; Sometimes, you need to iteratively
compute estimates of the diffusivity. This supplies an
initial displacement that will be added on to the initial
displacements. Note that this makes sense only when
smoothed=False.</li>
<li><strong>initial_structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Like initial_disp, this is used
for iterative computations of estimates of the diffusivity. You
typically need to supply both variables. This stipulates the
initial strcture from which the current set of displacements
are computed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.from_vaspruns">
<em class="property">classmethod </em><code class="descname">from_vaspruns</code><span class="sig-paren">(</span><em>vaspruns</em>, <em>specie</em>, <em>smoothed='max'</em>, <em>min_obs=30</em>, <em>avg_nsteps=1000</em>, <em>initial_disp=None</em>, <em>initial_structure=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.from_vaspruns"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.from_vaspruns" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenient constructor that takes in a list of Vasprun objects to
perform diffusion analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vaspruns</strong> (<em>[Vasprun]</em>) &#8211; List of Vaspruns (must be ordered  in
sequence of MD simulation). E.g., you may have performed
sequential VASP runs to obtain sufficient statistics.</li>
<li><strong>specie</strong> (<em>Element/Specie</em>) &#8211; Specie to calculate diffusivity for as a
String. E.g., &#8220;Li&#8221;.</li>
<li><strong>min_obs</strong> (<em>int</em>) &#8211; Minimum number of observations to have before
including in the MSD vs dt calculation. E.g. If a structure
has 10 diffusing atoms, and min_obs = 30, the MSD vs dt will be
calculated up to dt = total_run_time / 3, so that each
diffusing atom is measured at least 3 uncorrelated times.</li>
<li><strong>smoothed</strong> (<em>str</em>) &#8211; <p>Whether to smooth the MSD, and what mode to smooth.
Supported modes are:</p>
<ol class="lowerroman">
<li>&#8220;max&#8221;, which tries to use the maximum #
of data points for each time origin, subject to a
minimum # of observations given by min_obs, and then
weights the observations based on the variance
accordingly. This is the default.</li>
<li>&#8220;constant&#8221;, in which each timestep is averaged over
the same number of observations given by min_obs.</li>
<li>None / False / any other false-like quantity. No</li>
</ol>
<blockquote>
<div>smoothing.</div></blockquote>
</li>
<li><strong>min_obs</strong> &#8211; Used with smoothed=&#8221;max&#8221;. Minimum number of
observations to have before including in the MSD vs dt
calculation. E.g. If a structure has 10 diffusing atoms,
and min_obs = 30, the MSD vs dt will be
calculated up to dt = total_run_time / 3, so that each
diffusing atom is measured at least 3 uncorrelated times.
Only applies in smoothed=&#8221;max&#8221;.</li>
<li><strong>avg_nsteps</strong> (<em>int</em>) &#8211; Used with smoothed=&#8221;constant&#8221;. Determines the
number of time steps to average over to get the msd for each
timestep. Default of 1000 is usually pretty good.</li>
<li><strong>initial_disp</strong> (<em>np.ndarray</em>) &#8211; Sometimes, you need to iteratively
compute estimates of the diffusivity. This supplies an
initial displacement that will be added on to the initial
displacements. Note that this makes sense only when
smoothed=False.</li>
<li><strong>initial_structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Like initial_disp, this is used
for iterative computations of estimates of the diffusivity. You
typically need to supply both variables. This stipulates the
initial strcture from which the current set of displacements
are computed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.get_drift_corrected_structures">
<code class="descname">get_drift_corrected_structures</code><span class="sig-paren">(</span><em>start=None</em>, <em>stop=None</em>, <em>step=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.get_drift_corrected_structures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.get_drift_corrected_structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator for the drift-corrected structures. Use of
iterator is to reduce memory usage as # of structures in MD can be
huge. You don&#8217;t often need all the structures all at once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stop, step</strong> (<em>start,</em>) &#8211; applies a start/stop/step to the iterator.
Faster than applying it after generation, as it reduces the
number of structures created.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.get_framework_rms_plot">
<code class="descname">get_framework_rms_plot</code><span class="sig-paren">(</span><em>plt=None</em>, <em>granularity=200</em>, <em>matching_s=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.get_framework_rms_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.get_framework_rms_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the plot of rms framework displacement vs time. Useful for checking
for melting, especially if framework atoms can move via paddle-wheel
or similar mechanism (which would show up in max framework displacement
but doesn&#8217;t constitute melting).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>granularity</strong> (<em>int</em>) &#8211; Number of structures to match</li>
<li><strong>matching_s</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Optionally match to a disordered structure
instead of the first structure in the analyzer. Required when
a secondary mobile ion is present.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.get_msd_plot">
<code class="descname">get_msd_plot</code><span class="sig-paren">(</span><em>plt=None</em>, <em>mode='specie'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.get_msd_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.get_msd_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the plot of the smoothed msd vs time graph. Useful for
checking convergence. This can be written to an image file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>plt</strong> &#8211; A plot object. Defaults to None, which means one will be
generated.</li>
<li><strong>mode</strong> (<em>str</em>) &#8211; Determines type of msd plot. By &#8220;species&#8221;, &#8220;sites&#8221;,
or direction (default).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.get_summary_dict">
<code class="descname">get_summary_dict</code><span class="sig-paren">(</span><em>include_msd_t=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.get_summary_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.get_summary_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a summary of diffusion information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>include_msd_t</strong> (<em>bool</em>) &#8211; Whether to include mean square displace and
time data with the data.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(dict) of diffusion and conductivity data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.plot_msd">
<code class="descname">plot_msd</code><span class="sig-paren">(</span><em>mode='default'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#DiffusionAnalyzer.plot_msd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.DiffusionAnalyzer.plot_msd" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the smoothed msd vs time graph. Useful for checking convergence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mode</strong> (<em>str</em>) &#8211; Either &#8220;default&#8221; (the default, shows only the MSD for
the diffusing specie, and its components), &#8220;ions&#8221; (individual
square displacements of all ions), or &#8220;species&#8221; (mean square
displacement by specie).</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.diffusion_analyzer.fit_arrhenius">
<code class="descname">fit_arrhenius</code><span class="sig-paren">(</span><em>temps</em>, <em>diffusivities</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#fit_arrhenius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.fit_arrhenius" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Returns Ea, c, standard error of Ea from the Arrhenius fit:</dt>
<dd>D = c * exp(-Ea/kT)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>temps</strong> (<em>[float]</em>) &#8211; A sequence of temperatures. units: K</li>
<li><strong>diffusivities</strong> (<em>[float]</em>) &#8211; A sequence of diffusivities (e.g.,
from DiffusionAnalyzer.diffusivity). units: cm^2/s</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.diffusion_analyzer.get_arrhenius_plot">
<code class="descname">get_arrhenius_plot</code><span class="sig-paren">(</span><em>temps</em>, <em>diffusivities</em>, <em>diffusivity_errors=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#get_arrhenius_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.get_arrhenius_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an Arrhenius plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>temps</strong> (<em>[float]</em>) &#8211; A sequence of temperatures.</li>
<li><strong>diffusivities</strong> (<em>[float]</em>) &#8211; A sequence of diffusivities (e.g.,
from DiffusionAnalyzer.diffusivity).</li>
<li><strong>diffusivity_errors</strong> (<em>[float]</em>) &#8211; A sequence of errors for the
diffusivities. If None, no error bar is plotted.</li>
<li><strong>**kwargs</strong> &#8211; Any keyword args supported by matplotlib.pyplot.plot.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A matplotlib.pyplot object. Do plt.show() to show the plot.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.diffusion_analyzer.get_conversion_factor">
<code class="descname">get_conversion_factor</code><span class="sig-paren">(</span><em>structure</em>, <em>species</em>, <em>temperature</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#get_conversion_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.get_conversion_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversion factor to convert between cm^2/s diffusivity measurements and
mS/cm conductivity measurements based on number of atoms of diffusing
species. Note that the charge is based on the oxidation state of the
species (where available), or else the number of valence electrons
(usually a good guess, esp for main group ions).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Input structure.</li>
<li><strong>species</strong> (<em>Element/Specie</em>) &#8211; Diffusing species.</li>
<li><strong>temperature</strong> (<em>float</em>) &#8211; Temperature of the diffusion run in Kelvin.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Conversion factor.
Conductivity (in mS/cm) = Conversion Factor * Diffusivity (in cm^2/s)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.diffusion_analyzer.get_extrapolated_conductivity">
<code class="descname">get_extrapolated_conductivity</code><span class="sig-paren">(</span><em>temps</em>, <em>diffusivities</em>, <em>new_temp</em>, <em>structure</em>, <em>species</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#get_extrapolated_conductivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.get_extrapolated_conductivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns extrapolated mS/cm conductivity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>temps</strong> (<em>[float]</em>) &#8211; A sequence of temperatures. units: K</li>
<li><strong>diffusivities</strong> (<em>[float]</em>) &#8211; A sequence of diffusivities (e.g.,
from DiffusionAnalyzer.diffusivity). units: cm^2/s</li>
<li><strong>new_temp</strong> (<em>float</em>) &#8211; desired temperature. units: K</li>
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.VolumetricData.structure" title="pymatgen.io.vasp.outputs.VolumetricData.structure"><em>structure</em></a>) &#8211; Structure used for the diffusivity calculation</li>
<li><strong>species</strong> (<em>string/Specie</em>) &#8211; conducting species</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(float) Conductivity at extrapolated temp in mS/cm.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.diffusion_analyzer.get_extrapolated_diffusivity">
<code class="descname">get_extrapolated_diffusivity</code><span class="sig-paren">(</span><em>temps</em>, <em>diffusivities</em>, <em>new_temp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/diffusion_analyzer.html#get_extrapolated_diffusivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.diffusion_analyzer.get_extrapolated_diffusivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns (Arrhenius) extrapolated diffusivity at new_temp</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>temps</strong> (<em>[float]</em>) &#8211; A sequence of temperatures. units: K</li>
<li><strong>diffusivities</strong> (<em>[float]</em>) &#8211; A sequence of diffusivities (e.g.,
from DiffusionAnalyzer.diffusivity). units: cm^2/s</li>
<li><strong>new_temp</strong> (<em>float</em>) &#8211; desired temperature. units: K</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(float) Diffusivity at extrapolated temp in mS/cm.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.energy_models">
<span id="pymatgen-analysis-energy-models-module"></span><h2>pymatgen.analysis.energy_models module<a class="headerlink" href="#module-pymatgen.analysis.energy_models" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.energy_models.EnergyModel">
<em class="property">class </em><code class="descname">EnergyModel</code><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#EnergyModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.EnergyModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>Abstract structure filter class.</p>
<dl class="classmethod">
<dt id="pymatgen.analysis.energy_models.EnergyModel.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#EnergyModel.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.EnergyModel.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.energy_models.EnergyModel.get_energy">
<code class="descname">get_energy</code><span class="sig-paren">(</span><em>structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#EnergyModel.get_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.EnergyModel.get_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean for any structure. Structures that return true are
kept in the Transmuter object during filtering.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.energy_models.EwaldElectrostaticModel">
<em class="property">class </em><code class="descname">EwaldElectrostaticModel</code><span class="sig-paren">(</span><em>real_space_cut=None</em>, <em>recip_space_cut=None</em>, <em>eta=None</em>, <em>acc_factor=8.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#EwaldElectrostaticModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.EwaldElectrostaticModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.energy_models.EnergyModel" title="pymatgen.analysis.energy_models.EnergyModel"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.energy_models.EnergyModel</span></code></a></p>
<p>Wrapper around EwaldSum to calculate the electrostatic energy.</p>
<p>Initializes the model. Args have the same definitions as in
<a class="reference internal" href="#pymatgen.analysis.ewald.EwaldSummation" title="pymatgen.analysis.ewald.EwaldSummation"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.ewald.EwaldSummation</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>real_space_cut</strong> (<em>float</em>) &#8211; Real space cutoff radius dictating how
many terms are used in the real space sum. Defaults to None,
which means determine automagically using the formula given
in gulp 3.1 documentation.</li>
<li><strong>recip_space_cut</strong> (<em>float</em>) &#8211; Reciprocal space cutoff radius.
Defaults to None, which means determine automagically using
the formula given in gulp 3.1 documentation.</li>
<li><strong>eta</strong> (<em>float</em>) &#8211; Screening parameter. Defaults to None, which means
determine automatically.</li>
<li><strong>acc_factor</strong> (<em>float</em>) &#8211; No. of significant figures each sum is
converged to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.energy_models.EwaldElectrostaticModel.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#EwaldElectrostaticModel.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.EwaldElectrostaticModel.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.energy_models.EwaldElectrostaticModel.get_energy">
<code class="descname">get_energy</code><span class="sig-paren">(</span><em>structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#EwaldElectrostaticModel.get_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.EwaldElectrostaticModel.get_energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.energy_models.IsingModel">
<em class="property">class </em><code class="descname">IsingModel</code><span class="sig-paren">(</span><em>j</em>, <em>max_radius</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#IsingModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.IsingModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.energy_models.EnergyModel" title="pymatgen.analysis.energy_models.EnergyModel"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.energy_models.EnergyModel</span></code></a></p>
<p>A very simple Ising model, with r^2 decay.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>j</strong> (<em>float</em>) &#8211; The interaction parameter. E = J * spin1 * spin2.</li>
<li><strong>radius</strong> (<em>float</em>) &#8211; max_radius for the interaction.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.energy_models.IsingModel.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#IsingModel.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.IsingModel.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.energy_models.IsingModel.get_energy">
<code class="descname">get_energy</code><span class="sig-paren">(</span><em>structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#IsingModel.get_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.IsingModel.get_energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.energy_models.NsitesModel">
<em class="property">class </em><code class="descname">NsitesModel</code><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#NsitesModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.NsitesModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.energy_models.EnergyModel" title="pymatgen.analysis.energy_models.EnergyModel"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.energy_models.EnergyModel</span></code></a></p>
<p>Sets the energy to the number of sites. More sites =&gt; higher &#8220;energy&#8221;.
Used to rank structures from smallest number of sites to largest number
of sites after enumeration.</p>
<dl class="method">
<dt id="pymatgen.analysis.energy_models.NsitesModel.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#NsitesModel.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.NsitesModel.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.energy_models.NsitesModel.get_energy">
<code class="descname">get_energy</code><span class="sig-paren">(</span><em>structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#NsitesModel.get_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.NsitesModel.get_energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.energy_models.SymmetryModel">
<em class="property">class </em><code class="descname">SymmetryModel</code><span class="sig-paren">(</span><em>symprec=0.1</em>, <em>angle_tolerance=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#SymmetryModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.SymmetryModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.energy_models.EnergyModel" title="pymatgen.analysis.energy_models.EnergyModel"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.energy_models.EnergyModel</span></code></a></p>
<p>Sets the energy to the -ve of the spacegroup number. Higher symmetry =&gt;
lower &#8220;energy&#8221;.</p>
<p>Args have same meaning as in
<code class="xref py py-class docutils literal"><span class="pre">pymatgen.symmetry.finder.SpacegroupAnalyzer</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>symprec</strong> (<em>float</em>) &#8211; Symmetry tolerance. Defaults to 0.1.</li>
<li><strong>angle_tolerance</strong> (<em>float</em>) &#8211; Tolerance for angles. Defaults to 5 degrees.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.energy_models.SymmetryModel.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#SymmetryModel.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.SymmetryModel.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.energy_models.SymmetryModel.get_energy">
<code class="descname">get_energy</code><span class="sig-paren">(</span><em>structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/energy_models.html#SymmetryModel.get_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.energy_models.SymmetryModel.get_energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.eos">
<span id="pymatgen-analysis-eos-module"></span><h2>pymatgen.analysis.eos module<a class="headerlink" href="#module-pymatgen.analysis.eos" title="Permalink to this headline">¶</a></h2>
<p>Tools to compute equations of states with different models.</p>
<dl class="class">
<dt id="pymatgen.analysis.eos.EOS">
<em class="property">class </em><code class="descname">EOS</code><span class="sig-paren">(</span><em>eos_name='murnaghan'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Fit equation of state for bulk systems.</p>
<p>The following equation is used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">murnaghan</span>
    <span class="n">PRB</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">5480</span> <span class="p">(</span><span class="mi">1983</span><span class="p">)</span>

<span class="n">birch</span>
    <span class="n">Intermetallic</span> <span class="n">compounds</span><span class="p">:</span> <span class="n">Principles</span> <span class="ow">and</span> <span class="n">Practice</span><span class="p">,</span> <span class="n">Vol</span> <span class="n">I</span><span class="p">:</span> <span class="n">Principles</span><span class="o">.</span> <span class="n">pages</span> <span class="mi">195</span><span class="o">-</span><span class="mi">210</span>

<span class="n">birch_murnaghan</span>
    <span class="n">PRB</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">224107</span>

<span class="n">pourier_tarantola</span>
    <span class="n">PRB</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">224107</span>

<span class="n">vinet</span>
    <span class="n">PRB</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">224107</span>
</pre></div>
</div>
<p>Use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">eos</span> <span class="o">=</span> <span class="n">EOS</span><span class="p">(</span><span class="n">eos_name</span><span class="o">=</span><span class="s1">&#39;murnaghan&#39;</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">eos</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">volumes</span><span class="p">,</span> <span class="n">energies</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
<span class="n">fit</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<dl class="staticmethod">
<dt id="pymatgen.analysis.eos.EOS.Birch">
<em class="property">static </em><code class="descname">Birch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS.Birch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS.Birch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.eos.EOS.Birch_Murnaghan">
<em class="property">static </em><code class="descname">Birch_Murnaghan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS.Birch_Murnaghan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS.Birch_Murnaghan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.eos.EOS.DeltaFactor">
<em class="property">static </em><code class="descname">DeltaFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS.DeltaFactor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS.DeltaFactor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.eos.EOS.Error">
<code class="descname">Error</code><a class="headerlink" href="#pymatgen.analysis.eos.EOS.Error" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">EOSError</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.eos.EOS.MODELS">
<code class="descname">MODELS</code><em class="property"> = {'birch': &lt;function birch&gt;, 'pourier_tarantola': &lt;function pourier_tarantola&gt;, 'murnaghan': &lt;function murnaghan&gt;, 'deltafactor': &lt;function deltafactor_polyfit&gt;, 'quadratic': &lt;function quadratic&gt;, 'birch_murnaghan': &lt;function birch_murnaghan&gt;, 'vinet': &lt;function vinet&gt;}</em><a class="headerlink" href="#pymatgen.analysis.eos.EOS.MODELS" title="Permalink to this definition">¶</a></dt>
<dd><p>Models available.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.eos.EOS.Murnaghan">
<em class="property">static </em><code class="descname">Murnaghan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS.Murnaghan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS.Murnaghan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.eos.EOS.Pourier_Tarantola">
<em class="property">static </em><code class="descname">Pourier_Tarantola</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS.Pourier_Tarantola"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS.Pourier_Tarantola" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.eos.EOS.Quadratic">
<em class="property">static </em><code class="descname">Quadratic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS.Quadratic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS.Quadratic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.eos.EOS.Vinet">
<em class="property">static </em><code class="descname">Vinet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS.Vinet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS.Vinet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.eos.EOS.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>volumes</em>, <em>energies</em>, <em>vol_unit='ang^3'</em>, <em>ene_unit='eV'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/eos.html#EOS.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.eos.EOS.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit energies [eV] as function of volumes [Angstrom**3].</p>
<p>Returns <cite>EosFit</cite> instance that gives access to the optimal volume,
the minumum energy, and the bulk modulus.
Notice that the units for the bulk modulus is eV/Angstrom^3.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.ewald">
<span id="pymatgen-analysis-ewald-module"></span><h2>pymatgen.analysis.ewald module<a class="headerlink" href="#module-pymatgen.analysis.ewald" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer">
<em class="property">class </em><code class="descname">EwaldMinimizer</code><span class="sig-paren">(</span><em>matrix</em>, <em>m_list</em>, <em>num_to_return=1</em>, <em>algo=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#EwaldMinimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class determines the manipulations that will minimize an ewald matrix,
given a list of possible manipulations. This class does not perform the
manipulations on a structure, but will return the list of manipulations
that should be done on one to produce the minimal structure. It returns the
manipulations for the n lowest energy orderings. This class should be used
to perform fractional species substitution or fractional species removal to
produce a new structure. These manipulations create large numbers of
candidate structures, and this class can be used to pick out those with the
lowest ewald sum.</p>
<p>An alternative (possibly more intuitive) interface to this class is the
order disordered structure transformation.</p>
<p>Author - Will Richards</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>matrix</strong> &#8211; A matrix of the ewald sum interaction energies. This is stored
in the class as a diagonally symmetric array and so
self._matrix will not be the same as the input matrix.</li>
<li><strong>m_list</strong> &#8211; list of manipulations. each item is of the form
(multiplication fraction, number_of_indices, indices, species)
These are sorted such that the first manipulation contains the
most permutations. this is actually evaluated last in the
recursion since I&#8217;m using pop.</li>
<li><strong>num_to_return</strong> &#8211; The minimizer will find the number_returned lowest
energy structures. This is likely to return a number of duplicate
structures so it may be necessary to overestimate and then
remove the duplicates later. (duplicate checking in this
process is extremely expensive)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.ALGO_BEST_FIRST">
<code class="descname">ALGO_BEST_FIRST</code><em class="property"> = 2</em><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.ALGO_BEST_FIRST" title="Permalink to this definition">¶</a></dt>
<dd><p><em>ALGO_TIME_LIMIT</em> &#8211; Slowly increases the speed (with the cost of decreasing
accuracy) as the minimizer runs. Attempts to limit the run time to
approximately 30 minutes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.ALGO_COMPLETE">
<code class="descname">ALGO_COMPLETE</code><em class="property"> = 1</em><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.ALGO_COMPLETE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.ALGO_FAST">
<code class="descname">ALGO_FAST</code><em class="property"> = 0</em><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.ALGO_FAST" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.ALGO_TIME_LIMIT">
<code class="descname">ALGO_TIME_LIMIT</code><em class="property"> = 3</em><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.ALGO_TIME_LIMIT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.add_m_list">
<code class="descname">add_m_list</code><span class="sig-paren">(</span><em>matrix_sum</em>, <em>m_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#EwaldMinimizer.add_m_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.add_m_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This adds an m_list to the output_lists and updates the current
minimum if the list is full.</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.best_case">
<code class="descname">best_case</code><span class="sig-paren">(</span><em>matrix</em>, <em>m_list</em>, <em>indices_left</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#EwaldMinimizer.best_case"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.best_case" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a best case given a matrix and manipulation list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>matrix</strong> &#8211; the current matrix (with some permutations already
performed)</li>
<li><strong>m_list</strong> &#8211; [(multiplication fraction, number_of_indices, indices,
species)] describing the manipulation</li>
<li><strong>indices</strong> &#8211; Set of indices which haven&#8217;t had a permutation
performed on them.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.best_m_list">
<code class="descname">best_m_list</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.best_m_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.get_next_index">
<code class="descname">get_next_index</code><span class="sig-paren">(</span><em>matrix</em>, <em>manipulation</em>, <em>indices_left</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#EwaldMinimizer.get_next_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.get_next_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an index that should have the most negative effect on the
matrix sum</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.minimize_matrix">
<code class="descname">minimize_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#EwaldMinimizer.minimize_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.minimize_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This method finds and returns the permutations that produce the lowest
ewald sum calls recursive function to iterate through permutations</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.minimized_sum">
<code class="descname">minimized_sum</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.minimized_sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldMinimizer.output_lists">
<code class="descname">output_lists</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldMinimizer.output_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.ewald.EwaldSummation">
<em class="property">class </em><code class="descname">EwaldSummation</code><span class="sig-paren">(</span><em>structure</em>, <em>real_space_cut=None</em>, <em>recip_space_cut=None</em>, <em>eta=None</em>, <em>acc_factor=12.0</em>, <em>w=0.7071067811865475</em>, <em>compute_forces=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#EwaldSummation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Calculates the electrostatic energy of a periodic array of charges using
the Ewald technique.
Ref: <a class="reference external" href="http://www.ee.duke.edu/~ayt/ewaldpaper/ewaldpaper.html">http://www.ee.duke.edu/~ayt/ewaldpaper/ewaldpaper.html</a></p>
<p>This matrix can be used to do fast calculations of ewald sums after species
removal.</p>
<p>E = E_recip + E_real + E_point</p>
<p>Atomic units used in the code, then converted to eV.</p>
<p>Initializes and calculates the Ewald sum. Default convergence
parameters have been specified, but you can override them if you wish.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Input structure that must have proper
Specie on all sites, i.e. Element with oxidation state. Use
Structure.add_oxidation_state... for example.</li>
<li><strong>real_space_cut</strong> (<em>float</em>) &#8211; Real space cutoff radius dictating how
many terms are used in the real space sum. Defaults to None,
which means determine automagically using the formula given
in gulp 3.1 documentation.</li>
<li><strong>recip_space_cut</strong> (<em>float</em>) &#8211; Reciprocal space cutoff radius.
Defaults to None, which means determine automagically using
the formula given in gulp 3.1 documentation.</li>
<li><strong>eta</strong> (<em>float</em>) &#8211; The screening parameter. Defaults to None, which means
determine automatically.</li>
<li><strong>acc_factor</strong> (<em>float</em>) &#8211; No. of significant figures each sum is
converged to.</li>
<li><strong>w</strong> (<em>float</em>) &#8211; Weight parameter, w, has been included that represents
the relative computational expense of calculating a term in
real and reciprocal space. Default of 0.7 reproduces result
similar to GULP 4.2. This has little effect on the total
energy, but may influence speed of computation in large
systems. Note that this parameter is used only when the
cutoffs are set to None.</li>
<li><strong>compute_forces</strong> (<em>bool</em>) &#8211; Whether to compute forces. False by
default since it is usually not needed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.CONV_FACT">
<code class="descname">CONV_FACT</code><em class="property"> = 14.399645351950547</em><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.CONV_FACT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.ewald.EwaldSummation.compute_partial_energy">
<code class="descname">compute_partial_energy</code><span class="sig-paren">(</span><em>removed_indices</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#EwaldSummation.compute_partial_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.compute_partial_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives total ewald energy for certain sites being removed, i.e. zeroed
out.</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.ewald.EwaldSummation.compute_sub_structure">
<code class="descname">compute_sub_structure</code><span class="sig-paren">(</span><em>sub_structure</em>, <em>tol=0.001</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#EwaldSummation.compute_sub_structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.compute_sub_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives total ewald energy for an sub structure in the same
lattice. The sub_structure must be a subset of the original
structure, with possible different charges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>substructure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Substructure to compute Ewald sum for.</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; Tolerance for site matching in fractional coordinates.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Ewald sum of substructure.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.eta">
<code class="descname">eta</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.eta" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.forces">
<code class="descname">forces</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.forces" title="Permalink to this definition">¶</a></dt>
<dd><p>The forces on each site as a Nx3 matrix. Each row corresponds to a
site.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.point_energy">
<code class="descname">point_energy</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.point_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>The point energy.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.point_energy_matrix">
<code class="descname">point_energy_matrix</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.point_energy_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The point space matrix. A diagonal matrix with the point terms for each
site in the diagonal elements.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.real_space_energy">
<code class="descname">real_space_energy</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.real_space_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>The real space space energy.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.real_space_energy_matrix">
<code class="descname">real_space_energy_matrix</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.real_space_energy_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The real space energy matrix. Each matrix element (i, j) corresponds to
the interaction energy between site i and site j in real space.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.reciprocal_space_energy">
<code class="descname">reciprocal_space_energy</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.reciprocal_space_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>The reciprocal space energy.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.reciprocal_space_energy_matrix">
<code class="descname">reciprocal_space_energy_matrix</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.reciprocal_space_energy_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The reciprocal space energy matrix. Each matrix element (i, j)
corresponds to the interaction energy between site i and site j in
reciprocal space.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.total_energy">
<code class="descname">total_energy</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.total_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>The total energy.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.ewald.EwaldSummation.total_energy_matrix">
<code class="descname">total_energy_matrix</code><a class="headerlink" href="#pymatgen.analysis.ewald.EwaldSummation.total_energy_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The total energy matrix. Each matrix element (i, j) corresponds to the
total interaction energy between site i and site j.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.ewald.compute_average_oxidation_state">
<code class="descname">compute_average_oxidation_state</code><span class="sig-paren">(</span><em>site</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/ewald.html#compute_average_oxidation_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.ewald.compute_average_oxidation_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the average oxidation state of a site</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>site</strong> &#8211; Site to compute average oxidation state</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Average oxidation state of site.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.molecule_matcher">
<span id="pymatgen-analysis-molecule-matcher-module"></span><h2>pymatgen.analysis.molecule_matcher module<a class="headerlink" href="#module-pymatgen.analysis.molecule_matcher" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper">
<em class="property">class </em><code class="descname">AbstractMolAtomMapper</code><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#AbstractMolAtomMapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>Abstract molecular atom order mapping class. A mapping will be able to
find the uniform atom order of two molecules that can pair the
geometrically equivalent atoms.</p>
<dl class="classmethod">
<dt id="pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#AbstractMolAtomMapper.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper.get_molecule_hash">
<code class="descname">get_molecule_hash</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#AbstractMolAtomMapper.get_molecule_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper.get_molecule_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a hash for molecules. This allows molecules to be grouped
efficiently for comparison.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mol</strong> &#8211; The molecule. OpenBabel OBMol or pymatgen Molecule object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A hashable object. Examples can be string formulas, etc.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper.uniform_labels">
<code class="descname">uniform_labels</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#AbstractMolAtomMapper.uniform_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper.uniform_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pair the geometrically equivalent atoms of the molecules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol1</strong> &#8211; First molecule. OpenBabel OBMol or pymatgen Molecule object.</li>
<li><strong>mol2</strong> &#8211; Second molecule. OpenBabel OBMol or pymatgen Molecule object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(list1, list2) if uniform atom order is found. list1 and list2
are for mol1 and mol2, respectively. Their length equal
to the number of atoms. They represents the uniform atom order
of the two molecules. The value of each element is the original
atom index in mol1 or mol2 of the current atom in uniform atom
order.
(None, None) if unform atom is not available.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.molecule_matcher.InchiMolAtomMapper">
<em class="property">class </em><code class="descname">InchiMolAtomMapper</code><span class="sig-paren">(</span><em>angle_tolerance=10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#InchiMolAtomMapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.InchiMolAtomMapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper" title="pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper</span></code></a></p>
<p>Pair atoms by inchi labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>angle_tolerance</strong> &#8211; Angle threshold to assume linear molecule. In degrees.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.InchiMolAtomMapper.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#InchiMolAtomMapper.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.InchiMolAtomMapper.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.molecule_matcher.InchiMolAtomMapper.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#InchiMolAtomMapper.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.InchiMolAtomMapper.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.InchiMolAtomMapper.get_molecule_hash">
<code class="descname">get_molecule_hash</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#InchiMolAtomMapper.get_molecule_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.InchiMolAtomMapper.get_molecule_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Return inchi as molecular hash</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.InchiMolAtomMapper.uniform_labels">
<code class="descname">uniform_labels</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#InchiMolAtomMapper.uniform_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.InchiMolAtomMapper.uniform_labels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper">
<em class="property">class </em><code class="descname">IsomorphismMolAtomMapper</code><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#IsomorphismMolAtomMapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper" title="pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.molecule_matcher.AbstractMolAtomMapper</span></code></a></p>
<p>Pair atoms by isomorphism permutations in the OpenBabel::OBAlign class</p>
<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#IsomorphismMolAtomMapper.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#IsomorphismMolAtomMapper.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper.get_molecule_hash">
<code class="descname">get_molecule_hash</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#IsomorphismMolAtomMapper.get_molecule_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper.get_molecule_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Return inchi as molecular hash</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper.uniform_labels">
<code class="descname">uniform_labels</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#IsomorphismMolAtomMapper.uniform_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.IsomorphismMolAtomMapper.uniform_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pair the geometrically equivalent atoms of the molecules.
Calculate RMSD on all possible isomorphism mappings and return mapping
with the least RMSD</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol1</strong> &#8211; First molecule. OpenBabel OBMol or pymatgen Molecule object.</li>
<li><strong>mol2</strong> &#8211; Second molecule. OpenBabel OBMol or pymatgen Molecule object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(list1, list2) if uniform atom order is found. list1 and list2
are for mol1 and mol2, respectively. Their length equal
to the number of atoms. They represents the uniform atom order
of the two molecules. The value of each element is the original
atom index in mol1 or mol2 of the current atom in uniform atom
order.
(None, None) if unform atom is not available.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.molecule_matcher.MoleculeMatcher">
<em class="property">class </em><code class="descname">MoleculeMatcher</code><span class="sig-paren">(</span><em>tolerance=0.01</em>, <em>mapper=&lt;pymatgen.analysis.molecule_matcher.InchiMolAtomMapper object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#MoleculeMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.MoleculeMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>Class to match molecules and identify whether molecules are the same.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tolerance</strong> &#8211; RMSD difference threshold whether two molecules are
different</li>
<li><strong>mapper</strong> &#8211; MolAtomMapper object that is able to map the atoms of two
molecule to uniform order</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.MoleculeMatcher.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#MoleculeMatcher.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.MoleculeMatcher.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.MoleculeMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#MoleculeMatcher.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.MoleculeMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit two molecules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol1</strong> &#8211; First molecule. OpenBabel OBMol or pymatgen Molecule object</li>
<li><strong>mol2</strong> &#8211; Second molecule. OpenBabel OBMol or pymatgen Molecule object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A boolean value indicates whether two molecules are the same.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.molecule_matcher.MoleculeMatcher.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#MoleculeMatcher.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.MoleculeMatcher.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.MoleculeMatcher.get_rmsd">
<code class="descname">get_rmsd</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#MoleculeMatcher.get_rmsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.MoleculeMatcher.get_rmsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get RMSD between two molecule with arbitrary atom order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">RMSD if topology of the two molecules are the same
Infinite if  the topology is different</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_matcher.MoleculeMatcher.group_molecules">
<code class="descname">group_molecules</code><span class="sig-paren">(</span><em>mol_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_matcher.html#MoleculeMatcher.group_molecules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_matcher.MoleculeMatcher.group_molecules" title="Permalink to this definition">¶</a></dt>
<dd><p>Group molecules by structural equality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mol_list</strong> &#8211; List of OpenBabel OBMol or pymatgen objects</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of lists of matched molecules
Assumption: if s1=s2 and s2=s3, then s1=s3
This may not be true for small tolerances.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.molecule_structure_comparator">
<span id="pymatgen-analysis-molecule-structure-comparator-module"></span><h2>pymatgen.analysis.molecule_structure_comparator module<a class="headerlink" href="#module-pymatgen.analysis.molecule_structure_comparator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.molecule_structure_comparator.CovalentRadius">
<em class="property">class </em><code class="descname">CovalentRadius</code><a class="reference internal" href="_modules/pymatgen/analysis/molecule_structure_comparator.html#CovalentRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.CovalentRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Covalent Radius of the elements.</p>
<p>Beatriz C. et al. Dalton Trans. 2008, 2832-2838. DOI: 10.1039/b801115j</p>
<dl class="attribute">
<dt id="pymatgen.analysis.molecule_structure_comparator.CovalentRadius.radius">
<code class="descname">radius</code><em class="property"> = {'Pu': 1.87, 'B': 0.84, 'Ac': 2.15, 'Te': 1.38, 'Pr': 2.03, 'Se': 1.2, 'Fe': 1.42, 'Pd': 1.39, 'Zn': 1.22, 'In': 1.42, 'S': 1.05, 'Kr': 1.16, 'U': 1.96, 'Al': 1.21, 'Mg': 1.41, 'Th': 2.06, 'Tm': 1.9, 'K': 2.03, 'Sc': 1.7, 'Ru': 1.46, 'Er': 1.89, 'F': 0.57, 'Ni': 1.24, 'Dy': 1.92, 'Ir': 1.41, 'Xe': 1.4, 'I': 1.39, 'Ge': 1.2, 'Pm': 1.99, 'Rh': 1.42, 'Be': 0.96, 'Nb': 1.64, 'Sn': 1.39, 'Lu': 1.87, 'Hg': 1.32, 'La': 2.07, 'Am': 1.8, 'Cd': 1.44, 'Yb': 1.87, 'Sb': 1.39, 'Sm': 1.98, 'Cr': 1.39, 'Br': 1.2, 'Pb': 1.46, 'Tc': 1.47, 'Ba': 2.15, 'Ca': 1.76, 'W': 1.62, 'Li': 1.28, 'Re': 1.51, 'Ga': 1.22, 'Po': 1.4, 'Rn': 1.5, 'Pt': 1.36, 'Ce': 2.04, 'Si': 1.11, 'Cu': 1.32, 'Ne': 0.58, 'Hf': 1.75, 'N': 0.71, 'Ar': 1.06, 'Pa': 2.0, 'Ti': 1.6, 'Sr': 1.95, 'Cl': 1.02, 'Y': 1.9, 'Zr': 1.75, 'Nd': 2.01, 'Gd': 1.96, 'Na': 1.66, 'Ag': 1.45, 'Mo': 1.54, 'P': 1.07, 'Fr': 2.6, 'Eu': 1.98, 'Co': 1.38, 'Tl': 1.45, 'Au': 1.36, 'Tb': 1.94, 'O': 0.66, 'Bi': 1.48, 'H': 0.31, 'He': 0.28, 'Cm': 1.69, 'Ra': 2.21, 'Np': 1.9, 'Ho': 1.92, 'Ta': 1.7, 'At': 1.5, 'Mn': 1.5, 'Cs': 2.44, 'Rb': 2.2, 'Os': 1.44, 'As': 1.19, 'V': 1.53, 'C': 0.73}</em><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.CovalentRadius.radius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator">
<em class="property">class </em><code class="descname">MoleculeStructureComparator</code><span class="sig-paren">(</span><em>bond_length_cap=0.3</em>, <em>covalent_radius={'Pu': 1.87</em>, <em>'B': 0.84</em>, <em>'Ac': 2.15</em>, <em>'Te': 1.38</em>, <em>'Pr': 2.03</em>, <em>'Se': 1.2</em>, <em>'Fe': 1.42</em>, <em>'Pd': 1.39</em>, <em>'Zn': 1.22</em>, <em>'In': 1.42</em>, <em>'S': 1.05</em>, <em>'Kr': 1.16</em>, <em>'U': 1.96</em>, <em>'Al': 1.21</em>, <em>'Mg': 1.41</em>, <em>'Th': 2.06</em>, <em>'Tm': 1.9</em>, <em>'K': 2.03</em>, <em>'Sc': 1.7</em>, <em>'Ru': 1.46</em>, <em>'Er': 1.89</em>, <em>'F': 0.57</em>, <em>'Ni': 1.24</em>, <em>'Dy': 1.92</em>, <em>'Ir': 1.41</em>, <em>'Xe': 1.4</em>, <em>'I': 1.39</em>, <em>'Ge': 1.2</em>, <em>'Pm': 1.99</em>, <em>'Rh': 1.42</em>, <em>'Be': 0.96</em>, <em>'Nb': 1.64</em>, <em>'Sn': 1.39</em>, <em>'Lu': 1.87</em>, <em>'Hg': 1.32</em>, <em>'La': 2.07</em>, <em>'Am': 1.8</em>, <em>'Cd': 1.44</em>, <em>'Yb': 1.87</em>, <em>'Sb': 1.39</em>, <em>'Sm': 1.98</em>, <em>'Cr': 1.39</em>, <em>'Br': 1.2</em>, <em>'Pb': 1.46</em>, <em>'Tc': 1.47</em>, <em>'Ba': 2.15</em>, <em>'Ca': 1.76</em>, <em>'W': 1.62</em>, <em>'Li': 1.28</em>, <em>'Re': 1.51</em>, <em>'Ga': 1.22</em>, <em>'Po': 1.4</em>, <em>'Rn': 1.5</em>, <em>'Pt': 1.36</em>, <em>'Ce': 2.04</em>, <em>'Si': 1.11</em>, <em>'Cu': 1.32</em>, <em>'Ne': 0.58</em>, <em>'Hf': 1.75</em>, <em>'N': 0.71</em>, <em>'Ar': 1.06</em>, <em>'Pa': 2.0</em>, <em>'Ti': 1.6</em>, <em>'Sr': 1.95</em>, <em>'Cl': 1.02</em>, <em>'Y': 1.9</em>, <em>'Zr': 1.75</em>, <em>'Nd': 2.01</em>, <em>'Gd': 1.96</em>, <em>'Na': 1.66</em>, <em>'Ag': 1.45</em>, <em>'Mo': 1.54</em>, <em>'P': 1.07</em>, <em>'Fr': 2.6</em>, <em>'Eu': 1.98</em>, <em>'Co': 1.38</em>, <em>'Tl': 1.45</em>, <em>'Au': 1.36</em>, <em>'Tb': 1.94</em>, <em>'O': 0.66</em>, <em>'Bi': 1.48</em>, <em>'H': 0.31</em>, <em>'He': 0.28</em>, <em>'Cm': 1.69</em>, <em>'Ra': 2.21</em>, <em>'Np': 1.9</em>, <em>'Ho': 1.92</em>, <em>'Ta': 1.7</em>, <em>'At': 1.5</em>, <em>'Mn': 1.5</em>, <em>'Cs': 2.44</em>, <em>'Rb': 2.2</em>, <em>'Os': 1.44</em>, <em>'As': 1.19</em>, <em>'V': 1.53</em>, <em>'C': 0.73}</em>, <em>priority_bonds=()</em>, <em>priority_cap=0.8</em>, <em>ignore_ionic_bond=True</em>, <em>bond_13_cap=0.05</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_structure_comparator.html#MoleculeStructureComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>Class to check whether the connection tables of the two molecules are the
same. The atom in the two molecule must be paired accordingly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bond_length_cap</strong> &#8211; The ratio of the elongation of the bond to be
acknowledged. If the distance between two atoms is less than (
empirical covalent bond length) X (1 + bond_length_cap), the bond
between the two atoms will be acknowledged.</li>
<li><strong>covalent_radius</strong> &#8211; The covalent radius of the atoms.
dict (element symbol -&gt; radius)</li>
<li><strong>priority_bonds</strong> &#8211; The bonds that are known to be existed in the initial
molecule. Such bonds will be acknowledged in a loose criteria.
The index should start from 0.</li>
<li><strong>priority_cap</strong> &#8211; The ratio of the elongation of the bond to be
acknowledged for the priority bonds.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.are_equal">
<code class="descname">are_equal</code><span class="sig-paren">(</span><em>mol1</em>, <em>mol2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_structure_comparator.html#MoleculeStructureComparator.are_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.are_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the bond table of the two molecules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mol1</strong> &#8211; first molecule. pymatgen Molecule object.</li>
<li><strong>mol2</strong> &#8211; second moleculs. pymatgen Molecule objec.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_structure_comparator.html#MoleculeStructureComparator.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_structure_comparator.html#MoleculeStructureComparator.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.get_13_bonds">
<em class="property">static </em><code class="descname">get_13_bonds</code><span class="sig-paren">(</span><em>priority_bonds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/molecule_structure_comparator.html#MoleculeStructureComparator.get_13_bonds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.get_13_bonds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.halogen_list">
<code class="descname">halogen_list</code><em class="property"> = ['F', 'Cl', 'Br', 'I']</em><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.halogen_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.ionic_element_list">
<code class="descname">ionic_element_list</code><em class="property"> = ['Na', 'Mg', 'Al', 'Sc', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Rb', 'Sr']</em><a class="headerlink" href="#pymatgen.analysis.molecule_structure_comparator.MoleculeStructureComparator.ionic_element_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.nmr">
<span id="pymatgen-analysis-nmr-module"></span><h2>pymatgen.analysis.nmr module<a class="headerlink" href="#module-pymatgen.analysis.nmr" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation">
<em class="property">class </em><code class="descname">NMRChemicalShiftNotation</code><span class="sig-paren">(</span><em>sigma_1</em>, <em>sigma_2</em>, <em>sigma_3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/nmr.html#NMRChemicalShiftNotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>Helper class to convert between different chemical shift conventions
internally using the Mehring notation. Note that this is different than the
default notion adopted by VASP which is the Maryland notation.</p>
<p>Three notations to describe chemical shift tensor (RK Harris; Magn. Reson.
Chem. 2008, 46, 582–598; DOI: 10.1002/mrc.2225) are supported.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma_1</strong> (<em>float</em>) &#8211; chemical shift tensor principle component 1</li>
<li><strong>sigma_2</strong> (<em>float</em>) &#8211; chemical shift tensor principle component 2</li>
<li><strong>sigma_3</strong> (<em>float</em>) &#8211; chemical shift tensor principle component 3</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt>
<code class="descname">sigma_11, simga_22, sigma33</code></dt>
<dt>
<code class="descname">principle components in Mehring notation</code></dt>
<dd></dd></dl>

<p>Authors: Xiaohui Qu</p>
<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.HaeberlenNotation">
<code class="descname">HaeberlenNotation</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.HaeberlenNotation" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">HaeberlenNotion</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MarylandNotation">
<em class="property">class </em><code class="descname">MarylandNotation</code><span class="sig-paren">(</span><em>sigma_iso</em>, <em>omega</em>, <em>kappa</em><span class="sig-paren">)</span><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MarylandNotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<p>Create new instance of MarylandNotation(sigma_iso, omega, kappa)</p>
<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MarylandNotation.kappa">
<code class="descname">kappa</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MarylandNotation.kappa" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MarylandNotation.omega">
<code class="descname">omega</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MarylandNotation.omega" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MarylandNotation.sigma_iso">
<code class="descname">sigma_iso</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MarylandNotation.sigma_iso" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation">
<em class="property">class </em><code class="descclassname">NMRChemicalShiftNotation.</code><code class="descname">MehringNotation</code><span class="sig-paren">(</span><em>sigma_iso</em>, <em>sigma_11</em>, <em>sigma_22</em>, <em>sigma_33</em><span class="sig-paren">)</span><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">tuple</span></code></p>
<p>Create new instance of MehringNotation(sigma_iso, sigma_11, sigma_22, sigma_33)</p>
<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation.sigma_11">
<code class="descname">sigma_11</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation.sigma_11" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation.sigma_22">
<code class="descname">sigma_22</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation.sigma_22" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation.sigma_33">
<code class="descname">sigma_33</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation.sigma_33" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 3</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation.sigma_iso">
<code class="descname">sigma_iso</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.MehringNotation.sigma_iso" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.as_dict">
<code class="descclassname">NMRChemicalShiftNotation.</code><code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/nmr.html#NMRChemicalShiftNotation.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.from_dict">
<em class="property">classmethod </em><code class="descclassname">NMRChemicalShiftNotation.</code><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/nmr.html#NMRChemicalShiftNotation.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.from_maryland_notation">
<em class="property">classmethod </em><code class="descclassname">NMRChemicalShiftNotation.</code><code class="descname">from_maryland_notation</code><span class="sig-paren">(</span><em>sigma_iso</em>, <em>omega</em>, <em>kappa</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/nmr.html#NMRChemicalShiftNotation.from_maryland_notation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.from_maryland_notation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.haeberlen_values">
<code class="descclassname">NMRChemicalShiftNotation.</code><code class="descname">haeberlen_values</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.haeberlen_values" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Returns</em> &#8211; the Chemical shift tensor in Haeberlen Notation</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.maryland_values">
<code class="descclassname">NMRChemicalShiftNotation.</code><code class="descname">maryland_values</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.maryland_values" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Returns</em> &#8211; the Chemical shift tensor in Maryland Notation</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.nmr.NMRChemicalShiftNotation.mehring_values">
<code class="descclassname">NMRChemicalShiftNotation.</code><code class="descname">mehring_values</code><a class="headerlink" href="#pymatgen.analysis.nmr.NMRChemicalShiftNotation.mehring_values" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Returns</em> &#8211; the Chemical shift tensor in Mehring Notation</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.piezo">
<span id="pymatgen-analysis-piezo-module"></span><h2>pymatgen.analysis.piezo module<a class="headerlink" href="#module-pymatgen.analysis.piezo" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.piezo.PiezoTensor">
<em class="property">class </em><code class="descname">PiezoTensor</code><a class="reference internal" href="_modules/pymatgen/analysis/piezo.html#PiezoTensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.piezo.PiezoTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pymatgen.analysis.elasticity.html#pymatgen.analysis.elasticity.tensors.TensorBase" title="pymatgen.analysis.elasticity.tensors.TensorBase"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.elasticity.tensors.TensorBase</span></code></a></p>
<p>This class describes the 3x6 piezo tensor in Voigt-notation</p>
<p>Create an PiezoTensor object.  The constructor throws an error if
the shape of the input_matrix argument is not 3x3x3, i. e. in true
tensor notation. Note that the constructor uses __new__ rather than
__init__ according to the standard method of subclassing numpy
ndarrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_matrix</strong> (<em>3x3x3 array-like</em>) &#8211; the 3x6 array-like
representing the piezo tensor</td>
</tr>
</tbody>
</table>
<dl class="classmethod">
<dt id="pymatgen.analysis.piezo.PiezoTensor.from_voigt">
<em class="property">classmethod </em><code class="descname">from_voigt</code><span class="sig-paren">(</span><em>voigt_matrix</em>, <em>tol=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/piezo.html#PiezoTensor.from_voigt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.piezo.PiezoTensor.from_voigt" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor based on 3x6 voigt-notation tensor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>voigt_matrix</strong> &#8211; (3x6 array-like): The Voigt notation 3x6 array-like
representing the piezo tensor</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.piezo.PiezoTensor.voigt">
<code class="descname">voigt</code><a class="headerlink" href="#pymatgen.analysis.piezo.PiezoTensor.voigt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 3x6 voigt notation tensor corresponding
to the piezo tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>c_ijkl</strong> (<em>3x3x3 array-like</em>) &#8211; third order tensor corresponding
to the piezo tensor</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; tolerance for the symmetry test of the tensor</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.reaction_calculator">
<span id="pymatgen-analysis-reaction-calculator-module"></span><h2>pymatgen.analysis.reaction_calculator module<a class="headerlink" href="#module-pymatgen.analysis.reaction_calculator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction">
<em class="property">class </em><code class="descname">BalancedReaction</code><span class="sig-paren">(</span><em>reactants_coeffs</em>, <em>products_coeffs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>An object representing a complete chemical reaction.</p>
<p>Reactants and products to be specified as dict of {Composition: coeff}.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>({Composition</strong> (<a class="reference internal" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.products" title="pymatgen.analysis.reaction_calculator.BalancedReaction.products"><em>products</em></a>) &#8211; float}): Reactants as dict of
{Composition: amt}.</li>
<li><strong>({Composition</strong> &#8211; float}): Products as dict of
{Composition: amt}.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.TOLERANCE">
<code class="descname">TOLERANCE</code><em class="property"> = 1e-06</em><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.TOLERANCE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.all_comp">
<code class="descname">all_comp</code><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.all_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>List of all compositions in the reaction.</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.as_entry">
<code class="descname">as_entry</code><span class="sig-paren">(</span><em>energies</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.as_entry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.as_entry" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ComputedEntry representation of the reaction.
:return:</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.calculate_energy">
<code class="descname">calculate_energy</code><span class="sig-paren">(</span><em>energies</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.calculate_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.calculate_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the energy of the reaction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>({Composition</strong> (<a class="reference internal" href="pymatgen.io.html#pymatgen.io.gaussian.GaussianOutput.energies" title="pymatgen.io.gaussian.GaussianOutput.energies"><em>energies</em></a>) &#8211; float}): Energy for each composition.
E.g ., {comp1: energy1, comp2: energy2}.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">reaction energy as a float.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.coeffs">
<code class="descname">coeffs</code><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Final coefficients of the calculated reaction</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.elements">
<code class="descname">elements</code><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.elements" title="Permalink to this definition">¶</a></dt>
<dd><p>List of elements in the reaction</p>
</dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.from_string">
<em class="property">static </em><code class="descname">from_string</code><span class="sig-paren">(</span><em>rxn_string</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.from_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a balanced reaction from a string. The reaction must
already be balanced.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rxn_string</strong> &#8211; The reaction string. For example, &#8220;4 Li + O2-&gt; 2Li2O&#8221;</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">BalancedReaction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.get_coeff">
<code class="descname">get_coeff</code><span class="sig-paren">(</span><em>comp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.get_coeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.get_coeff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns coefficient for a particular composition</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.get_el_amount">
<code class="descname">get_el_amount</code><span class="sig-paren">(</span><em>element</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.get_el_amount"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.get_el_amount" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the amount of the element in the reaction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>element</strong> (<em>Element/Specie</em>) &#8211; Element in the reaction</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Amount of that element in the reaction.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.normalize_to">
<code class="descname">normalize_to</code><span class="sig-paren">(</span><em>comp</em>, <em>factor=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.normalize_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.normalize_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes the reaction to one of the compositions.
By default, normalizes such that the composition given has a
coefficient of 1. Another factor can be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>comp</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.composition.Composition" title="pymatgen.core.composition.Composition"><em>Composition</em></a>) &#8211; Composition to normalize to</li>
<li><strong>factor</strong> (<em>float</em>) &#8211; Factor to normalize to. Defaults to 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.normalize_to_element">
<code class="descname">normalize_to_element</code><span class="sig-paren">(</span><em>element</em>, <em>factor=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.normalize_to_element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.normalize_to_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes the reaction to one of the elements.
By default, normalizes such that the amount of the element is 1.
Another factor can be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>element</strong> (<em>Element/Specie</em>) &#8211; Element to normalize to.</li>
<li><strong>factor</strong> (<em>float</em>) &#8211; Factor to normalize to. Defaults to 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.normalized_repr">
<code class="descname">normalized_repr</code><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.normalized_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>A normalized representation of the reaction. All factors are converted
to lowest common factors.</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.normalized_repr_and_factor">
<code class="descname">normalized_repr_and_factor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#BalancedReaction.normalized_repr_and_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.normalized_repr_and_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalized representation for a reaction
For example, <code class="docutils literal"><span class="pre">4</span> <span class="pre">Li</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">O</span> <span class="pre">-&gt;</span> <span class="pre">2Li2O</span></code> becomes <code class="docutils literal"><span class="pre">2</span> <span class="pre">Li</span> <span class="pre">+</span> <span class="pre">O</span> <span class="pre">-&gt;</span> <span class="pre">Li2O</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.products">
<code class="descname">products</code><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.products" title="Permalink to this definition">¶</a></dt>
<dd><p>List of products</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.BalancedReaction.reactants">
<code class="descname">reactants</code><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.BalancedReaction.reactants" title="Permalink to this definition">¶</a></dt>
<dd><p>List of reactants</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.reaction_calculator.ComputedReaction">
<em class="property">class </em><code class="descname">ComputedReaction</code><span class="sig-paren">(</span><em>reactant_entries</em>, <em>product_entries</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#ComputedReaction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.ComputedReaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.reaction_calculator.Reaction" title="pymatgen.analysis.reaction_calculator.Reaction"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.reaction_calculator.Reaction</span></code></a></p>
<p>Convenience class to generate a reaction from ComputedEntry objects, with
some additional attributes, such as a reaction energy based on computed
energies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reactant_entries</strong> (<em>[ComputedEntry]</em>) &#8211; List of reactant_entries.</li>
<li><strong>product_entries</strong> (<em>[ComputedEntry]</em>) &#8211; List of product_entries.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.ComputedReaction.all_entries">
<code class="descname">all_entries</code><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.ComputedReaction.all_entries" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent of all_comp but returns entries, in the same order as the
coefficients.</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.ComputedReaction.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#ComputedReaction.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.ComputedReaction.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.reaction_calculator.ComputedReaction.calculated_reaction_energy">
<code class="descname">calculated_reaction_energy</code><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.ComputedReaction.calculated_reaction_energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.reaction_calculator.ComputedReaction.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#ComputedReaction.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.ComputedReaction.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.reaction_calculator.Reaction">
<em class="property">class </em><code class="descname">Reaction</code><span class="sig-paren">(</span><em>reactants</em>, <em>products</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#Reaction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.Reaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.reaction_calculator.BalancedReaction" title="pymatgen.analysis.reaction_calculator.BalancedReaction"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.reaction_calculator.BalancedReaction</span></code></a></p>
<p>A more flexible class representing a Reaction. The reaction amounts will
be automatically balanced.</p>
<p>Reactants and products to be specified as list of
pymatgen.core.structure.Composition.  e.g., [comp1, comp2]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reactants</strong> (<em>[Composition]</em>) &#8211; List of reactants.</li>
<li><strong>products</strong> (<em>[Composition]</em>) &#8211; List of products.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.Reaction.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#Reaction.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.Reaction.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.reaction_calculator.Reaction.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#Reaction.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.Reaction.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the Reaction object.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.reaction_calculator.Reaction.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#Reaction.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.Reaction.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pymatgen.analysis.reaction_calculator.ReactionError">
<em class="property">exception </em><code class="descname">ReactionError</code><span class="sig-paren">(</span><em>msg</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#ReactionError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.ReactionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">Exception</span></code></p>
<p>Exception class for Reactions. Allows more information in exception
messages to cover situations not covered by standard exception classes.</p>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.reaction_calculator.smart_float_gcd">
<code class="descname">smart_float_gcd</code><span class="sig-paren">(</span><em>list_of_floats</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/reaction_calculator.html#smart_float_gcd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.reaction_calculator.smart_float_gcd" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the great common denominator (gcd).  Works on floats as well as
integers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list_of_floats</strong> &#8211; List of floats to determine gcd.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.structure_analyzer">
<span id="pymatgen-analysis-structure-analyzer-module"></span><h2>pymatgen.analysis.structure_analyzer module<a class="headerlink" href="#module-pymatgen.analysis.structure_analyzer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters">
<em class="property">class </em><code class="descname">OrderParameters</code><span class="sig-paren">(</span><em>types</em>, <em>parameters=None</em>, <em>cutoff=-10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OrderParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class permits the calculation of various types of local order
parameters.</p>
<p>Create an OrderParameter analyzer instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>types</strong> (<em>[string]</em>) &#8211; <p>List of strings representing the types of order parameters
to be calculated. Note that multiple mentions of the
same type may occur. Currently available types are
&#8220;cn&#8221;  (simple coordination number&#8212;normalized,</p>
<blockquote>
<div>if desired),</div></blockquote>
<dl class="docutils">
<dt>&#8220;tet&#8221; [Shetty&#8211;Peters style OP recognizing tetrahedral</dt>
<dd>coordination (Zimmermann et al.,
J. Am. Chem. Soc., 137, 13352-13361, 2015)],</dd>
<dt>&#8220;oct&#8221; [Shetty&#8211;Peters style OP recognizing octahedral</dt>
<dd>coordination (Zimmermann et al.,
J. Am. Chem. Soc., 137, 13352-13361, 2015)],</dd>
<dt>&#8220;bcc&#8221; [Shetty&#8211;Peters style OP recognizing local</dt>
<dd>body-centered cubic environment (Peters,
J. Chem. Phys., 131, 244103, 2009)],</dd>
<dt>&#8220;q2&#8221;  [Bond orientational order parameter (BOOP)</dt>
<dd>of weight l=2 (Steinhardt et al., Phys. Rev. B,
28, 784-805, 1983)],</dd>
</dl>
<p>&#8220;q4&#8221;  (BOOP of weight l=4),
&#8220;q6&#8221;  (BOOP of weight l=6).</p>
</li>
<li><strong>parameters</strong> (<em>[[float]]</em>) &#8211; <p>2D list of floating point numbers that store
parameters associated with the different order parameters
that are to be calculated (1st dimension = length of
types tuple; any 2nd dimension may be zero, in which case
default values are used). In the following, those order
parameters q_i are listed that require further parameters
for their computation (values in brackets denote default
values):</p>
<blockquote>
<div>&#8220;cn&#8221;:  normalizing constant (1);
&#8220;tet&#8221;: Gaussian width in fractions of pi (180 degrees)<blockquote>
<div>reflecting the &#8220;speed of
penalizing&#8221; deviations away from the perfect
tetrahedral angle of any individual
neighbor1-center-neighbor2 configuration (0.0667);</div></blockquote>
<dl class="docutils">
<dt>&#8220;oct&#8221;: threshold angle in degrees distinguishing a second</dt>
<dd>neighbor to be either close to the south pole or
close to the equator (160.0);
Gaussian width for penalizing deviations away
from south pole (0.0667);
Gaussian width for penalizing deviations away
from equator (0.0556);
constant for shifting q_oct toward smaller
values, which can be helpful when trying to fine-
tune the capabilities of distinguishing between
different environments (e.g., tet vs oct)
given a single mutual threshold q_thresh;</dd>
<dt>&#8220;bcc&#8221;: south-pole threshold angle as for &#8220;oct&#8221; (160.0);</dt>
<dd>south-pole Gaussian width as for &#8220;oct&#8221; (0.0667).</dd>
</dl>
</div></blockquote>
</li>
<li><strong>cutoff</strong> (<em>float</em>) &#8211; Cutoff radius to determine which nearest neighbors are
supposed to contribute to the order parameters.
If the value is negative the neighboring sites found by
distance and cutoff radius are further
pruned using the get_coordinated_sites method from the
VoronoiCoordFinder class.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.compute_trigonometric_terms">
<code class="descname">compute_trigonometric_terms</code><span class="sig-paren">(</span><em>thetas=[]</em>, <em>phis=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OrderParameters.compute_trigonometric_terms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.compute_trigonometric_terms" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8221;
Computes trigonometric terms that are required to
calculate bond orientational order parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>thetas</strong> (<em>[float]</em>) &#8211; polar angles of all neighbors in radians.</li>
<li><strong>phis</strong> (<em>[float]</em>) &#8211; azimuth angles of all neighbors in radians.  The list of
azimuth angles is expected to have the same size as the list
of polar angles; otherwise, a ValueError is raised.  Also,
the two lists of angles have to be coherent in order. That
is, it is expected that the order in the list of azimuth
angles corresponds to a distinct sequence of neighbors.
And, this sequence has to equal the sequence
of neighbors in the list of polar angles.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.get_order_parameters">
<code class="descname">get_order_parameters</code><span class="sig-paren">(</span><em>structure</em>, <em>n</em>, <em>indeces_neighs=[]</em>, <em>tol=0.0</em>, <em>target_spec=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OrderParameters.get_order_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.get_order_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute all order parameters of site n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; input structure.</li>
<li><strong>n</strong> (<em>int</em>) &#8211; index of site in input structure, for which OPs are to be
calculated.  Note that we do not use the sites iterator
here, but directly access sites via struct[index].</li>
<li><strong>indeces_neighs</strong> (<em>[int]</em>) &#8211; list of indeces of those neighbors in Structure object
structure that are to be considered for OP computation.
This optional argument overwrites the way neighbors are
to be determined as defined in the constructor (i.e.,
Voronoi coordination finder via negative cutoff radius
vs constant cutoff radius if cutoff was positive).
We do not use information about the underlying
structure lattice if the neighbor indeces are explicitly
provided.  This has two important consequences.  First,
the input Structure object can, in fact, be a
simple list of Site objects.  Second, no nearest images
of neighbors are determined when providing an index list.
Note furthermore that this neighbor
determination type ignores the optional target_spec
argument.</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; threshold of weight (= solid angle / maximal solid angle)
to determine if a particular pair is
considered neighbors; this is relevant only in the case
when Voronoi polyhedra are used to determine coordination</li>
<li><strong>target_spec</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.periodic_table.Specie" title="pymatgen.core.periodic_table.Specie"><em>Specie</em></a>) &#8211; target specie to be considered when calculating the order
parameters of site n; None includes all species of input
structure.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of floats representing order parameters.  Should it not be
possible to compute a given OP for a conceptual reason, the
corresponding entry is None instead of a float.  For Steinhardt
et al.&#8217;s bond orientational OPs and the other geometric OPs
(&#8220;tet&#8221;, &#8220;oct&#8221;, &#8220;bcc&#8221;), this can happen if there is a single
neighbor around site n in the structure because that, obviously,
does not permit calculation of angles between multiple
neighbors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OrderParameters.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of floats that represents
the parameters associated with calculation of the order
parameter that was defined at the index provided.
Attention: the parameters do not need to equal those originally
inputted because of processing out of efficiency reasons.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>int</em>) &#8211; index of order-parameter for which associated parameters
are to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.get_q2">
<code class="descname">get_q2</code><span class="sig-paren">(</span><em>thetas=[]</em>, <em>phis=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OrderParameters.get_q2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.get_q2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the value of the bond orientational order parameter of
weight l=2.  If the function is called with non-empty lists of
polar and azimuthal angles the corresponding trigonometric terms
are computed afresh.  Otherwise, it is expected that the
compute_trigonometric_terms function has been just called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thetas</strong> (<em>[float]</em>) &#8211; polar angles of all neighbors in radians.</li>
<li><strong>phis</strong> (<em>[float]</em>) &#8211; azimuth angles of all neighbors in radians.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>bond orientational order parameter of weight l=2</dt>
<dd><p class="first last">corresponding to the input angles thetas and phis.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">q2 (float)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.get_q4">
<code class="descname">get_q4</code><span class="sig-paren">(</span><em>thetas=[]</em>, <em>phis=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OrderParameters.get_q4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.get_q4" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the value of the bond orientational order parameter of
weight l=4.  If the function is called with non-empty lists of
polar and azimuthal angles the corresponding trigonometric terms
are computed afresh.  Otherwise, it is expected that the
compute_trigonometric_terms function has been just called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thetas</strong> (<em>[float]</em>) &#8211; polar angles of all neighbors in radians.</li>
<li><strong>phis</strong> (<em>[float]</em>) &#8211; azimuth angles of all neighbors in radians.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>bond orientational order parameter of weight l=4</dt>
<dd><p class="first last">corresponding to the input angles thetas and phis.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">q4 (float)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.get_q6">
<code class="descname">get_q6</code><span class="sig-paren">(</span><em>thetas=[]</em>, <em>phis=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OrderParameters.get_q6"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.get_q6" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the value of the bond orientational order parameter of
weight l=6.  If the function is called with non-empty lists of
polar and azimuthal angles the corresponding trigonometric terms
are computed afresh.  Otherwise, it is expected that the
compute_trigonometric_terms function has been just called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>thetas</strong> (<em>[float]</em>) &#8211; polar angles of all neighbors in radians.</li>
<li><strong>phis</strong> (<em>[float]</em>) &#8211; azimuth angles of all neighbors in radians.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>bond orientational order parameter of weight l=6</dt>
<dd><p class="first last">corresponding to the input angles thetas and phis.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">q6 (float)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.get_type">
<code class="descname">get_type</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OrderParameters.get_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.get_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return type of order-parameter at the index provided and
represented by a short string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>int</em>) &#8211; index of order-parameter for which type is to be returned</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.last_nneigh">
<code class="descname">last_nneigh</code><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.last_nneigh" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8221;
Returns the number of neighbors encountered during the most
recent order-parameter calculation. A value of -1 indicates that
no such calculation has yet been performed for this instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.structure_analyzer.OrderParameters.num_ops">
<code class="descname">num_ops</code><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OrderParameters.num_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8221;
Returns the number of different order parameters that are targeted
to be calculated.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_analyzer.OxideType">
<em class="property">class </em><code class="descname">OxideType</code><span class="sig-paren">(</span><em>structure</em>, <em>relative_cutoff=1.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OxideType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OxideType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Separate class for determining oxide type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>structure</strong> &#8211; Input structure.</li>
<li><strong>relative_cutoff</strong> &#8211; Relative_cutoff * act. cutoff stipulates the max.
distance two O atoms must be from each other. Default value is
1.1. At most 1.1 is recommended, nothing larger, otherwise the
script cannot distinguish between superoxides and peroxides.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.OxideType.parse_oxide">
<code class="descname">parse_oxide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#OxideType.parse_oxide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.OxideType.parse_oxide" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if an oxide is a peroxide/superoxide/ozonide/normal oxide.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Type of oxide
ozonide/peroxide/superoxide/hydroxide/None.
nbonds (int): Number of peroxide/superoxide/hydroxide bonds in
structure.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">oxide_type (str)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_analyzer.RelaxationAnalyzer">
<em class="property">class </em><code class="descname">RelaxationAnalyzer</code><span class="sig-paren">(</span><em>initial_structure</em>, <em>final_structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#RelaxationAnalyzer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.RelaxationAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class analyzes the relaxation in a calculation.</p>
<p>Please note that the input and final structures should have the same
ordering of sites. This is typically the case for most computational
codes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>initial_structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Initial input structure to
calculation.</li>
<li><strong>final_structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Final output structure from
calculation.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.RelaxationAnalyzer.get_percentage_bond_dist_changes">
<code class="descname">get_percentage_bond_dist_changes</code><span class="sig-paren">(</span><em>max_radius=3.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#RelaxationAnalyzer.get_percentage_bond_dist_changes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.RelaxationAnalyzer.get_percentage_bond_dist_changes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the percentage bond distance changes for each site up to a
maximum radius for nearest neighbors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>max_radius</strong> (<em>float</em>) &#8211; Maximum radius to search for nearest
neighbors. This radius is applied to the initial structure,
not the final structure.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Bond distance changes as a dict of dicts. E.g.,
{index1: {index2: 0.011, ...}}. For economy of representation, the
index1 is always less than index2, i.e., since bonding between
site1 and siten is the same as bonding between siten and site1,
there is no reason to duplicate the information or computation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.RelaxationAnalyzer.get_percentage_lattice_parameter_changes">
<code class="descname">get_percentage_lattice_parameter_changes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#RelaxationAnalyzer.get_percentage_lattice_parameter_changes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.RelaxationAnalyzer.get_percentage_lattice_parameter_changes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the percentage lattice parameter changes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dict of the percentage change in lattice parameter, e.g.,
{&#8216;a&#8217;: 0.012, &#8216;b&#8217;: 0.021, &#8216;c&#8217;: -0.031} implies a change of 1.2%,
2.1% and -3.1% in the a, b and c lattice parameters respectively.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.RelaxationAnalyzer.get_percentage_volume_change">
<code class="descname">get_percentage_volume_change</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#RelaxationAnalyzer.get_percentage_volume_change"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.RelaxationAnalyzer.get_percentage_volume_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the percentage volume change.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Volume change in percentage, e.g., 0.055 implies a 5.5% increase.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiAnalyzer">
<em class="property">class </em><code class="descname">VoronoiAnalyzer</code><span class="sig-paren">(</span><em>cutoff=5.0</em>, <em>qhull_options='Qbb Qc Qz'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiAnalyzer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Performs a statistical analysis of Voronoi polyhedra around each site.
Each Voronoi polyhedron is described using Schaefli notation.
That is a set of indices {c_i} where c_i is the number of faces with i
number of vertices.  E.g. for a bcc crystal, there is only one polyhedron
notation of which is [0,6,0,8,0,0,...].
In perfect crystals, these also corresponds to the Wigner-Seitz cells.
For distorted-crystals, liquids or amorphous structures, rather than one-type,
there is a statistical distribution of polyhedra.
See ref: Microstructure and its relaxation in Fe-B amorphous system
simulated by molecular dynamics,</p>
<blockquote>
<div>Stepanyuk et al., J. Non-cryst. Solids (1993), 159, 80-87.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cutoff</strong> (<em>float</em>) &#8211; cutoff distance to search for neighbors of a given atom
(default = 5.0)</li>
<li><strong>qhull_options</strong> (<em>str</em>) &#8211; options to pass to qhull (optional)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiAnalyzer.analyze">
<code class="descname">analyze</code><span class="sig-paren">(</span><em>structure</em>, <em>n=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiAnalyzer.analyze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiAnalyzer.analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs Voronoi analysis and returns the polyhedra around atom n
in Schlaefli notation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; structure to analyze</li>
<li><strong>n</strong> (<em>int</em>) &#8211; index of the center atom in structure</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>&lt;c3,c4,c6,c6,c7,c8,c9,c10&gt;</dt>
<dd><p class="first last">where c_i denotes number of facets with i vertices.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">voronoi index of n</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiAnalyzer.analyze_structures">
<code class="descname">analyze_structures</code><span class="sig-paren">(</span><em>structures</em>, <em>step_freq=10</em>, <em>most_frequent_polyhedra=15</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiAnalyzer.analyze_structures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiAnalyzer.analyze_structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Voronoi analysis on a list of Structures.
Note that this might take a significant amount of time depending on the
size and number of structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>structures</strong> (<em>list</em>) &#8211; list of Structures</li>
<li><strong>(float</strong> (<em>cutoff</em>) &#8211; cutoff distance around an atom to search for
neighbors</li>
<li><strong>step_freq</strong> (<em>int</em>) &#8211; perform analysis every step_freq steps</li>
<li><strong>qhull_options</strong> (<em>str</em>) &#8211; options to pass to qhull</li>
<li><strong>most_frequent_polyhedra</strong> (<em>int</em>) &#8211; this many unique polyhedra with
highest frequences is stored.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of tuples in the form (voronoi_index,frequency)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiAnalyzer.plot_vor_analysis">
<em class="property">static </em><code class="descname">plot_vor_analysis</code><span class="sig-paren">(</span><em>voronoi_ensemble</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiAnalyzer.plot_vor_analysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiAnalyzer.plot_vor_analysis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiConnectivity">
<em class="property">class </em><code class="descname">VoronoiConnectivity</code><span class="sig-paren">(</span><em>structure</em>, <em>cutoff=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiConnectivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiConnectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Computes the solid angles swept out by the shared face of the voronoi
polyhedron between two sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Input structure</li>
<li><strong>cutoff</strong> (<em>float</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiConnectivity.connectivity_array">
<code class="descname">connectivity_array</code><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiConnectivity.connectivity_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides connectivity array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An array of shape [atomi, atomj, imagej]. atomi is
the index of the atom in the input structure. Since the second
atom can be outside of the unit cell, it must be described
by both an atom index and an image index. Array data is the
solid angle of polygon between atomi and imagej of atomj</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">connectivity</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiConnectivity.get_connections">
<code class="descname">get_connections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiConnectivity.get_connections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiConnectivity.get_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of site pairs that are Voronoi Neighbors, along
with their real-space distances.</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiConnectivity.get_sitej">
<code class="descname">get_sitej</code><span class="sig-paren">(</span><em>site_index</em>, <em>image_index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiConnectivity.get_sitej"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiConnectivity.get_sitej" title="Permalink to this definition">¶</a></dt>
<dd><p>Assuming there is some value in the connectivity array at indices
(1, 3, 12). sitei can be obtained directly from the input structure
(structure[1]). sitej can be obtained by passing 3, 12 to this function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>site_index</strong> (<em>int</em>) &#8211; index of the site (3 in the example)</li>
<li><strong>image_index</strong> (<em>int</em>) &#8211; index of the image (12 in the example)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiConnectivity.max_connectivity">
<code class="descname">max_connectivity</code><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiConnectivity.max_connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the 2d array [sitei, sitej] that represents
the maximum connectivity of site i to any periodic
image of site j</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiCoordFinder">
<em class="property">class </em><code class="descname">VoronoiCoordFinder</code><span class="sig-paren">(</span><em>structure</em>, <em>target=None</em>, <em>cutoff=10.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiCoordFinder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiCoordFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Uses a Voronoi algorithm to determine the coordination for each site in a
structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Input structure</li>
<li><strong>target</strong> (<em>[Element/Specie]</em>) &#8211; A list of target species to determine
coordination for.</li>
<li><strong>cutoff</strong> (<em>float</em>) &#8211; Radius in Angstrom cutoff to look for coordinating
atoms. Defaults to 10.0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiCoordFinder.get_coordinated_sites">
<code class="descname">get_coordinated_sites</code><span class="sig-paren">(</span><em>n</em>, <em>tol=0</em>, <em>target=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiCoordFinder.get_coordinated_sites"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiCoordFinder.get_coordinated_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sites that are in the coordination radius of site with
index n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>int</em>) &#8211; Site index.</li>
<li><strong>tol</strong> (<em>float</em>) &#8211; Weight tolerance to determine if a particular pair is
considered a neighbor.</li>
<li><strong>target</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.periodic_table.Element" title="pymatgen.core.periodic_table.Element"><em>Element</em></a>) &#8211; Target element</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Sites coordinating input site.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiCoordFinder.get_coordination_number">
<code class="descname">get_coordination_number</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiCoordFinder.get_coordination_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiCoordFinder.get_coordination_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coordination number of site with index n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>int</em>) &#8211; Site index</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_analyzer.VoronoiCoordFinder.get_voronoi_polyhedra">
<code class="descname">get_voronoi_polyhedra</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#VoronoiCoordFinder.get_voronoi_polyhedra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.VoronoiCoordFinder.get_voronoi_polyhedra" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a weighted polyhedra around a site. This uses the voronoi
construction with solid angle weights.
See ref: A Proposed Rigorous Definition of Coordination Number,
M. O&#8217;Keeffe, Acta Cryst. (1979). A35, 772-775</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>int</em>) &#8211; Site index</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict of sites sharing a common Voronoi facet with the site
n and their solid angle weights</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.structure_analyzer.average_coordination_number">
<code class="descname">average_coordination_number</code><span class="sig-paren">(</span><em>structures</em>, <em>freq=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#average_coordination_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.average_coordination_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the ensemble averaged Voronoi coordination numbers
of a list of Structures using VoronoiCoordFinder.
Typically used for analyzing the output of a Molecular Dynamics run.
:param structures: list of Structures.
:type structures: list
:param freq: sampling frequency of coordination number [every freq steps].
:type freq: int</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Dictionary of elements as keys and average coordination numbers as values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.structure_analyzer.contains_peroxide">
<code class="descname">contains_peroxide</code><span class="sig-paren">(</span><em>structure</em>, <em>relative_cutoff=1.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#contains_peroxide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.contains_peroxide" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if a structure contains peroxide anions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Input structure.</li>
<li><strong>relative_cutoff</strong> &#8211; The peroxide bond distance is 1.49 Angstrom.
Relative_cutoff * 1.49 stipulates the maximum distance two O
atoms must be to each other to be considered a peroxide.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Boolean indicating if structure contains a peroxide anion.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.structure_analyzer.gramschmidt">
<code class="descname">gramschmidt</code><span class="sig-paren">(</span><em>vin</em>, <em>uin</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#gramschmidt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.gramschmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns that part of the first input vector
that is orthogonal to the second input vector.
The output vector is not normalized.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vin</strong> (<em>numpy array</em>) &#8211; first input vector</li>
<li><strong>uin</strong> (<em>numpy array</em>) &#8211; second input vector</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.structure_analyzer.oxide_type">
<code class="descname">oxide_type</code><span class="sig-paren">(</span><em>structure</em>, <em>relative_cutoff=1.1</em>, <em>return_nbonds=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#oxide_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.oxide_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if an oxide is a peroxide/superoxide/ozonide/normal oxide</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Input structure.</li>
<li><strong>relative_cutoff</strong> (<em>float</em>) &#8211; Relative_cutoff * act. cutoff stipulates the
max distance two O atoms must be from each other.</li>
<li><strong>return_nbonds</strong> (<em>bool</em>) &#8211; Should number of bonds be requested?</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.structure_analyzer.solid_angle">
<code class="descname">solid_angle</code><span class="sig-paren">(</span><em>center</em>, <em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#solid_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.solid_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to calculate the solid angle of a set of coords from the
center.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>center</strong> (<em>3x1 array</em>) &#8211; Center to measure solid angle from.</li>
<li><strong>coords</strong> (<em>Nx3 array</em>) &#8211; List of coords to determine solid angle.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The solid angle.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.structure_analyzer.sulfide_type">
<code class="descname">sulfide_type</code><span class="sig-paren">(</span><em>structure</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_analyzer.html#sulfide_type"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_analyzer.sulfide_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines if a structure is a sulfide/polysulfide</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>structure</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Input structure.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(str) sulfide/polysulfide/sulfate</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.structure_matcher">
<span id="pymatgen-analysis-structure-matcher-module"></span><h2>pymatgen.analysis.structure_matcher module<a class="headerlink" href="#module-pymatgen.analysis.structure_matcher" title="Permalink to this headline">¶</a></h2>
<p>This module provides classes to perform fitting of structures.</p>
<dl class="class">
<dt id="pymatgen.analysis.structure_matcher.AbstractComparator">
<em class="property">class </em><code class="descname">AbstractComparator</code><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#AbstractComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.AbstractComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>Abstract Comparator class. A Comparator defines how sites are compared in
a structure.</p>
<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.AbstractComparator.are_equal">
<code class="descname">are_equal</code><span class="sig-paren">(</span><em>sp1</em>, <em>sp2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#AbstractComparator.are_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.AbstractComparator.are_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines how the species of two sites are considered equal. For
example, one can consider sites to have the same species only when
the species are exactly the same, i.e., Fe2+ matches Fe2+ but not
Fe3+. Or one can define that only the element matters,
and all oxidation state information are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sp1</strong> &#8211; First species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
<li><strong>sp2</strong> &#8211; Second species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Boolean indicating whether species are considered equal.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.AbstractComparator.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#AbstractComparator.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.AbstractComparator.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.structure_matcher.AbstractComparator.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#AbstractComparator.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.AbstractComparator.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.AbstractComparator.get_hash">
<code class="descname">get_hash</code><span class="sig-paren">(</span><em>composition</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#AbstractComparator.get_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.AbstractComparator.get_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a hash to group structures. This allows structures to be
grouped efficiently for comparison. The hash must be invariant under
supercell creation. (e.g. composition is not a good hash, but
fractional_composition might be). Reduced formula is not a good formula,
due to weird behavior with fractional occupancy.</p>
<p>Composition is used here instead of structure because for anonymous
matches it is much quicker to apply a substitution to a composition
object than a structure object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>composition</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.composition.Composition" title="pymatgen.core.composition.Composition"><em>Composition</em></a>) &#8211; composition of the structure</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A hashable object. Examples can be string formulas, integers etc.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_matcher.ElementComparator">
<em class="property">class </em><code class="descname">ElementComparator</code><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#ElementComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.ElementComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.structure_matcher.AbstractComparator" title="pymatgen.analysis.structure_matcher.AbstractComparator"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.structure_matcher.AbstractComparator</span></code></a></p>
<p>A Comparator that matches elements. i.e. oxidation states are
ignored.</p>
<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.ElementComparator.are_equal">
<code class="descname">are_equal</code><span class="sig-paren">(</span><em>sp1</em>, <em>sp2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#ElementComparator.are_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.ElementComparator.are_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if element:amounts are exactly the same, i.e.,
oxidation state is not considered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sp1</strong> &#8211; First species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
<li><strong>sp2</strong> &#8211; Second species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Boolean indicating whether species are the same based on element
and amounts.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.ElementComparator.get_hash">
<code class="descname">get_hash</code><span class="sig-paren">(</span><em>composition</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#ElementComparator.get_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.ElementComparator.get_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns: Fractional element composition</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_matcher.FrameworkComparator">
<em class="property">class </em><code class="descname">FrameworkComparator</code><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#FrameworkComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.FrameworkComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.structure_matcher.AbstractComparator" title="pymatgen.analysis.structure_matcher.AbstractComparator"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.structure_matcher.AbstractComparator</span></code></a></p>
<p>A Comparator that matches sites, regardless of species.</p>
<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.FrameworkComparator.are_equal">
<code class="descname">are_equal</code><span class="sig-paren">(</span><em>sp1</em>, <em>sp2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#FrameworkComparator.are_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.FrameworkComparator.are_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if there are atoms on both sites.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sp1</strong> &#8211; First species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
<li><strong>sp2</strong> &#8211; Second species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True always</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.FrameworkComparator.get_hash">
<code class="descname">get_hash</code><span class="sig-paren">(</span><em>composition</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#FrameworkComparator.get_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.FrameworkComparator.get_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>No hash possible</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_matcher.OrderDisorderElementComparator">
<em class="property">class </em><code class="descname">OrderDisorderElementComparator</code><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#OrderDisorderElementComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.OrderDisorderElementComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.structure_matcher.AbstractComparator" title="pymatgen.analysis.structure_matcher.AbstractComparator"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.structure_matcher.AbstractComparator</span></code></a></p>
<p>A Comparator that matches sites, given some overlap in the element
composition</p>
<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.OrderDisorderElementComparator.are_equal">
<code class="descname">are_equal</code><span class="sig-paren">(</span><em>sp1</em>, <em>sp2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#OrderDisorderElementComparator.are_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.OrderDisorderElementComparator.are_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if there is some overlap in composition between the species</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sp1</strong> &#8211; First species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
<li><strong>sp2</strong> &#8211; Second species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True always</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.OrderDisorderElementComparator.get_hash">
<code class="descname">get_hash</code><span class="sig-paren">(</span><em>composition</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#OrderDisorderElementComparator.get_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.OrderDisorderElementComparator.get_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8221;
No hash possible</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_matcher.SpeciesComparator">
<em class="property">class </em><code class="descname">SpeciesComparator</code><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#SpeciesComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.SpeciesComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.structure_matcher.AbstractComparator" title="pymatgen.analysis.structure_matcher.AbstractComparator"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.structure_matcher.AbstractComparator</span></code></a></p>
<p>A Comparator that matches species exactly. The default used in
StructureMatcher.</p>
<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.SpeciesComparator.are_equal">
<code class="descname">are_equal</code><span class="sig-paren">(</span><em>sp1</em>, <em>sp2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#SpeciesComparator.are_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.SpeciesComparator.are_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if species are exactly the same, i.e., Fe2+ == Fe2+ but not Fe3+.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sp1</strong> &#8211; First species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
<li><strong>sp2</strong> &#8211; Second species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Boolean indicating whether species are equal.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.SpeciesComparator.get_hash">
<code class="descname">get_hash</code><span class="sig-paren">(</span><em>composition</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#SpeciesComparator.get_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.SpeciesComparator.get_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns: Fractional composition</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_matcher.SpinComparator">
<em class="property">class </em><code class="descname">SpinComparator</code><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#SpinComparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.SpinComparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.analysis.structure_matcher.AbstractComparator" title="pymatgen.analysis.structure_matcher.AbstractComparator"><code class="xref py py-class docutils literal"><span class="pre">pymatgen.analysis.structure_matcher.AbstractComparator</span></code></a></p>
<p>A Comparator that matches magnetic structures to their inverse spins.
This comparator is primarily used to filter magnetically ordered
structures with opposite spins, which are equivalent.</p>
<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.SpinComparator.are_equal">
<code class="descname">are_equal</code><span class="sig-paren">(</span><em>sp1</em>, <em>sp2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#SpinComparator.are_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.SpinComparator.are_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if species are exactly the same, i.e., Fe2+ == Fe2+ but not
Fe3+. and the spins are reversed. i.e., spin up maps to spin down,
and vice versa.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sp1</strong> &#8211; First species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
<li><strong>sp2</strong> &#8211; Second species. A dict of {specie/element: amt} as per the
definition in Site and PeriodicSite.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Boolean indicating whether species are equal.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.SpinComparator.get_hash">
<code class="descname">get_hash</code><span class="sig-paren">(</span><em>composition</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#SpinComparator.get_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.SpinComparator.get_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns: Fractional composition</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher">
<em class="property">class </em><code class="descname">StructureMatcher</code><span class="sig-paren">(</span><em>ltol=0.2</em>, <em>stol=0.3</em>, <em>angle_tol=5</em>, <em>primitive_cell=True</em>, <em>scale=True</em>, <em>attempt_supercell=False</em>, <em>allow_subset=False</em>, <em>comparator=&lt;pymatgen.analysis.structure_matcher.SpeciesComparator object&gt;</em>, <em>supercell_size='num_sites'</em>, <em>ignored_species=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">monty.json.MSONable</span></code></p>
<p>Class to match structures by similarity.</p>
<p>Algorithm:</p>
<ol class="arabic">
<li><p class="first">Given two structures: s1 and s2</p>
</li>
<li><p class="first">Optional: Reduce to primitive cells.</p>
</li>
<li><p class="first">If the number of sites do not match, return False</p>
</li>
<li><p class="first">Reduce to s1 and s2 to Niggli Cells</p>
</li>
<li><p class="first">Optional: Scale s1 and s2 to same volume.</p>
</li>
<li><p class="first">Optional: Remove oxidation states associated with sites</p>
</li>
<li><p class="first">Find all possible lattice vectors for s2 within shell of ltol.</p>
</li>
<li><p class="first">For s1, translate an atom in the smallest set to the origin</p>
</li>
<li><p class="first">For s2: find all valid lattices from permutations of the list
of lattice vectors (invalid if: det(Lattice Matrix) &lt; half
volume of original s2 lattice)</p>
</li>
<li><p class="first">For each valid lattice:</p>
<ol class="loweralpha">
<li><p class="first">If the lattice angles of are within tolerance of s1,
basis change s2 into new lattice.</p>
</li>
<li><p class="first">For each atom in the smallest set of s2:</p>
<blockquote>
<div><p>i. Translate to origin and compare fractional sites in
structure within a fractional tolerance.
ii. If true:</p>
<blockquote>
<div><p>ia. Convert both lattices to cartesian and place
both structures on an average lattice
ib. Compute and return the average and max rms
displacement between the two structures normalized
by the average free length per atom</p>
<dl class="docutils">
<dt>if fit function called:</dt>
<dd><p class="first last">if normalized max rms displacement is less than
stol. Return True</p>
</dd>
<dt>if get_rms_dist function called:</dt>
<dd><p class="first last">if normalized average rms displacement is less
than the stored rms displacement, store and
continue. (This function will search all possible
lattices for the smallest average rms displacement
between the two structures)</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</li>
</ol>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ltol</strong> (<em>float</em>) &#8211; Fractional length tolerance. Default is 0.2.</li>
<li><strong>stol</strong> (<em>float</em>) &#8211; Site tolerance. Defined as the fraction of the
average free length per atom := ( V / Nsites ) ** (1/3)
Default is 0.3.</li>
<li><strong>angle_tol</strong> (<em>float</em>) &#8211; Angle tolerance in degrees. Default is 5 degrees.</li>
<li><strong>primitive_cell</strong> (<em>bool</em>) &#8211; If true: input structures will be reduced to
primitive cells prior to matching. Default to True.</li>
<li><strong>scale</strong> (<em>bool</em>) &#8211; Input structures are scaled to equivalent volume if
true; For exact matching, set to False.</li>
<li><strong>attempt_supercell</strong> (<em>bool</em>) &#8211; If set to True and number of sites in
cells differ after a primitive cell reduction (divisible by an
integer) attempts to generate a supercell transformation of the
smaller cell which is equivalent to the larger structure.</li>
<li><strong>allow_subset</strong> (<em>bool</em>) &#8211; Allow one structure to match to the subset of
another structure. Eg. Matching of an ordered structure onto a
disordered one, or matching a delithiated to a lithiated
structure. This option cannot be combined with
attempt_supercell, or with structure grouping.</li>
<li><strong>comparator</strong> (<em>Comparator</em>) &#8211; <p>A comparator object implementing an equals
method that declares declaring equivalency of sites. Default is
SpeciesComparator, which implies rigid species
mapping, i.e., Fe2+ only matches Fe2+ and not Fe3+.</p>
<p>Other comparators are provided, e.g., ElementComparator which
matches only the elements and not the species.</p>
<p>The reason why a comparator object is used instead of
supplying a comparison function is that it is not possible to
pickle a function, which makes it otherwise difficult to use
StructureMatcher with Python&#8217;s multiprocessing.</p>
</li>
<li><strong>supercell_size</strong> (<em>str</em>) &#8211; Method to use for determining the size of a
supercell (if applicable). Possible values are num_sites,
num_atoms, volume, or an element present in both structures.</li>
<li><strong>ignored_species</strong> (<em>list</em>) &#8211; A list of ions to be ignored in matching. Useful
for matching structures that have similar frameworks except for
certain ions, e.g., Li-ion intercalation frameworks. This is more
useful than allow_subset because it allows better control over
what species are ignored in the matching.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>struct1</em>, <em>struct2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit two structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>struct1</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 1st structure</li>
<li><strong>struct2</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 2nd structure</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True or False.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.fit_anonymous">
<code class="descname">fit_anonymous</code><span class="sig-paren">(</span><em>struct1</em>, <em>struct2</em>, <em>niggli=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.fit_anonymous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.fit_anonymous" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an anonymous fitting, which allows distinct species in one
structure to map to another. E.g., to compare if the Li2O and Na2O
structures are similar.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>struct1</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 1st structure</li>
<li><strong>struct2</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 2nd structure</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Whether a species mapping can map struct1 to stuct2</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">True/False</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.get_all_anonymous_mappings">
<code class="descname">get_all_anonymous_mappings</code><span class="sig-paren">(</span><em>struct1</em>, <em>struct2</em>, <em>niggli=True</em>, <em>include_dist=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.get_all_anonymous_mappings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.get_all_anonymous_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an anonymous fitting, which allows distinct species in one
structure to map to another. Returns a dictionary of species
substitutions that are within tolerance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>struct1</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 1st structure</li>
<li><strong>struct2</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 2nd structure</li>
<li><strong>niggli</strong> (<em>bool</em>) &#8211; Find niggli cell in preprocessing</li>
<li><strong>include_dist</strong> (<em>bool</em>) &#8211; Return the maximin distance with each mapping</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of species mappings that map struct1 to struct2.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.get_best_electronegativity_anonymous_mapping">
<code class="descname">get_best_electronegativity_anonymous_mapping</code><span class="sig-paren">(</span><em>struct1</em>, <em>struct2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.get_best_electronegativity_anonymous_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.get_best_electronegativity_anonymous_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an anonymous fitting, which allows distinct species in one
structure to map to another. E.g., to compare if the Li2O and Na2O
structures are similar. If multiple substitutions are within tolerance
this will return the one which minimizes the difference in
electronegativity between the matches species.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>struct1</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 1st structure</li>
<li><strong>struct2</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 2nd structure</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Mapping of struct1 species to struct2 species</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">min_mapping (Dict)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping">
<code class="descname">get_mapping</code><span class="sig-paren">(</span><em>superset</em>, <em>subset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.get_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.get_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mapping from superset to subset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>superset</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Structure containing at least the sites in
subset (within the structure matching tolerance)</li>
<li><strong>subset</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Structure containing some of the sites in
superset (within the structure matching tolerance)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array such that superset.sites[mapping] is within matching
tolerance of subset.sites or None if no such mapping is possible</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.get_rms_anonymous">
<code class="descname">get_rms_anonymous</code><span class="sig-paren">(</span><em>struct1</em>, <em>struct2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.get_rms_anonymous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.get_rms_anonymous" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an anonymous fitting, which allows distinct species in one
structure to map to another. E.g., to compare if the Li2O and Na2O
structures are similar.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>struct1</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 1st structure</li>
<li><strong>struct2</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 2nd structure</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(min_rms, min_mapping)
min_rms is the minimum rms distance, and min_mapping is the
corresponding minimal species mapping that would map
struct1 to struct2. (None, None) is returned if the minimax_rms
exceeds the threshold.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.get_rms_dist">
<code class="descname">get_rms_dist</code><span class="sig-paren">(</span><em>struct1</em>, <em>struct2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.get_rms_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.get_rms_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate RMS displacement between two structures</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>struct1</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 1st structure</li>
<li><strong>struct2</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; 2nd structure</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">rms displacement normalized by (Vol / nsites) ** (1/3)
and maximum distance between paired sites. If no matching
lattice is found None is returned.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.get_s2_like_s1">
<code class="descname">get_s2_like_s1</code><span class="sig-paren">(</span><em>struct1</em>, <em>struct2</em>, <em>include_ignored_species=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.get_s2_like_s1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.get_s2_like_s1" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs transformations on struct2 to put it in a basis similar to
struct1 (without changing any of the inter-site distances)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>struct1</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Reference structure</li>
<li><strong>struct2</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Structure to transform.</li>
<li><strong>include_ignored_species</strong> (<em>bool</em>) &#8211; Defaults to True,
the ignored_species is also transformed to the struct1
lattice orientation, though obviously there is no direct
matching to existing sites.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A structure object similar to struct1, obtained by making a
supercell, sorting, and translating struct2.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.get_supercell_matrix">
<code class="descname">get_supercell_matrix</code><span class="sig-paren">(</span><em>supercell</em>, <em>struct</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.get_supercell_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.get_supercell_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the matrix for transforming struct to supercell. This
can be used for very distorted &#8216;supercells&#8217; where the primitive cell
is impossible to find</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.get_transformation">
<code class="descname">get_transformation</code><span class="sig-paren">(</span><em>struct1</em>, <em>struct2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.get_transformation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.get_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the supercell transformation, fractional translation vector,
and a mapping to transform struct2 to be similar to struct1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>struct1</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Reference structure</li>
<li><strong>struct2</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Structure to transform.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>supercell matrix
vector (numpy.ndarray(3)): fractional translation vector
mapping (list(int or None)):</p>
<blockquote>
<div><p>The first len(struct1) items of the mapping vector are the
indices of struct1&#8217;s corresponding sites in struct2 (or None
if there is no corresponding site), and the other items are
the remaining site indices of struct2.</p>
</div></blockquote>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">supercell (numpy.ndarray(3, 3))</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.structure_matcher.StructureMatcher.group_structures">
<code class="descname">group_structures</code><span class="sig-paren">(</span><em>s_list</em>, <em>anonymous=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/structure_matcher.html#StructureMatcher.group_structures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.structure_matcher.StructureMatcher.group_structures" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of structures, use fit to group
them by structural equality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>s_list</strong> (<em>[Structure]</em>) &#8211; List of structures to be grouped</li>
<li><strong>anonymous</strong> (<em>bool</em>) &#8211; Wheher to use anonymous mode.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of lists of matched structures
Assumption: if s1 == s2 but s1 != s3, than s2 and s3 will be put
in different groups without comparison.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.substrate_analyzer">
<span id="pymatgen-analysis-substrate-analyzer-module"></span><h2>pymatgen.analysis.substrate_analyzer module<a class="headerlink" href="#module-pymatgen.analysis.substrate_analyzer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.substrate_analyzer.SubstrateAnalyzer">
<em class="property">class </em><code class="descname">SubstrateAnalyzer</code><span class="sig-paren">(</span><em>zslgen=&lt;pymatgen.analysis.substrate_analyzer.ZSLGenerator object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#SubstrateAnalyzer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.SubstrateAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class applies a set of search criteria to identify suitable
substrates for film growth. It first uses a topoplogical search by Zur
and McGill to identify matching super-lattices on various faces of the
two materials. Additional criteria can then be used to identify the most
suitable substrate. Currently, the only additional criteria is the
elastic strain energy of the super-lattices</p>
<p>Initializes the substrate analyzer
:param zslgen: Defaults to a ZSLGenerator with standard</p>
<blockquote>
<div>tolerances, but can be fed one with custom tolerances</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.SubstrateAnalyzer.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><em>film</em>, <em>substrate</em>, <em>elasticity_tensor=None</em>, <em>film_millers=None</em>, <em>substrate_millers=None</em>, <em>ground_state_energy=0</em>, <em>lowest=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#SubstrateAnalyzer.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.SubstrateAnalyzer.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all topological matches for the substrate and calculates elastic
strain energy and total energy for the film if elasticity tensor and
ground state energy are provided:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>film</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; conventional standard structure for the film</li>
<li><strong>substrate</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; conventional standard structure for the
substrate</li>
<li><strong>elasticity_tensor</strong> (<a class="reference internal" href="pymatgen.analysis.elasticity.html#pymatgen.analysis.elasticity.elastic.ElasticTensor" title="pymatgen.analysis.elasticity.elastic.ElasticTensor"><em>ElasticTensor</em></a>) &#8211; elasticity tensor for the film</li>
<li><strong>film_millers</strong> (<em>array</em>) &#8211; film facets to consider in search as defined by
miller indicies</li>
<li><strong>substrate_millers</strong> (<em>array</em>) &#8211; substrate facets to consider in search as
defined by miller indicies</li>
<li><strong>ground_state_energy</strong> (<em>float</em>) &#8211; ground state energy for the film</li>
<li><strong>lowest</strong> (<em>bool</em>) &#8211; only consider lowest matching area for each surface</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.SubstrateAnalyzer.calculate_3D_elastic_energy">
<code class="descname">calculate_3D_elastic_energy</code><span class="sig-paren">(</span><em>film</em>, <em>match</em>, <em>elasticity_tensor=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#SubstrateAnalyzer.calculate_3D_elastic_energy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.SubstrateAnalyzer.calculate_3D_elastic_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the multi-plane elastic energy. Returns 999 if no elastic
tensor was given on init</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator">
<em class="property">class </em><code class="descname">ZSLGenerator</code><span class="sig-paren">(</span><em>max_area_ratio_tol=0.09</em>, <em>max_area=400</em>, <em>film_max_miller=1</em>, <em>substrate_max_miller=1</em>, <em>max_length_tol=0.03</em>, <em>max_angle_tol=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class generate interface super lattices based on the methodology
of lattice vector matching for heterostructural interfaces proposed by
Zur and McGill:
Journal of Applied Physics 55 (1984), 378 ; doi: 10.1063/1.333084</p>
<p>The process of generating all possible interaces is as such:</p>
<dl class="docutils">
<dt>1.) Generate all slabs for the film and substrate for different orientations</dt>
<dd>given by maximum miller limitations</dd>
<dt>2.) For each film/substrate orientation pair:</dt>
<dd><p class="first">1.) Reduce lattice vectors and calculate area
2.) Generate all super lattice transformations within a maximum area</p>
<blockquote>
<div>limit that give nearly equal area super-lattices for the two
surfaces</div></blockquote>
<dl class="last docutils">
<dt>3.) For each superlattice set:</dt>
<dd><p class="first">1.) Reduce super lattice vectors
2.) Check length and angle between film and substrate super lattice</p>
<blockquote class="last">
<div>vectors to determine if the super lattices are the nearly same
and therefore coincident</div></blockquote>
</dd>
</dl>
</dd>
<dt>Intialize a Zur Super Lattice Generator for a specific film and</dt>
<dd>substrate</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>max_area_ratio_tol</strong> (<em>float</em>) &#8211; Max tolerance on ratio of
super-lattices to consider equal</li>
<li><strong>max_area</strong> (<em>float</em>) &#8211; max super lattice area to generate in search</li>
<li><strong>film_max_miller</strong> (<em>int</em>) &#8211; maximum miller index to generate for film
surfaces</li>
<li><strong>substrate_max_miller</strong> (<em>int</em>) &#8211; maximum miller index to generate for
substrate surfaces</li>
<li><strong>max_length_tol</strong> &#8211; maximum length tolerance in checking if two
vectors are of nearly the same length</li>
<li><strong>max_angle_tol</strong> &#8211; maximum angle tolerance in checking of two sets
of vectors have nearly the same angle between them</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.check_transformations">
<code class="descname">check_transformations</code><span class="sig-paren">(</span><em>transformation_sets</em>, <em>film_vectors</em>, <em>substrate_vectors</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.check_transformations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.check_transformations" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the transformation_sets to the film and substrate vectors
to generate super-lattices and checks if they matches.
Returns all matching vectors sets.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>transformation_sets</strong> (<em>array</em>) &#8211; an array of transformation sets:
each transformation set is an array with the (i,j)
indicating the area multipes of the film and subtrate it
corresponds to, an array with all possible transformations
for the film area multiple i and another array for the
substrate area multiple j.</li>
<li><strong>film_vectors</strong> (<em>array</em>) &#8211; film vectors to generate super lattices</li>
<li><strong>substrate_vectors</strong> (<em>array</em>) &#8211; substrate vectors to generate super
lattices</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>film</em>, <em>substrate</em>, <em>film_millers=None</em>, <em>substrate_millers=None</em>, <em>lowest=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the film/substrate combinations for either set miller
indicies or all possible miller indices up to a max miller index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>film</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) &#8211; Conventional standard pymatgen structure for
the film</li>
<li><strong>substrate</strong> (<em>Struture</em>) &#8211; Conventional standard pymatgen Structure
for the substrate</li>
<li><strong>film_millers</strong> (<em>array</em>) &#8211; array of film miller indicies to consider
in the matching algorithm</li>
<li><strong>substrate_millers</strong> (<em>array</em>) &#8211; array of substrate miller indicies to
consider in the matching algorithm</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.generate_sl_transformation">
<code class="descname">generate_sl_transformation</code><span class="sig-paren">(</span><em>area_multiple</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.generate_sl_transformation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.generate_sl_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the transformation matricies that convert a set of 2D
vectors into a super lattice of integer area multiple as proven
in Cassels:</p>
<p>Cassels, John William Scott. An introduction to the geometry of
numbers. Springer Science &amp; Business Media, 2012.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>area_multiple</strong> (<em>int</em>) &#8211; integer multiple of unit cell area for super</li>
<li><strong>area</strong> (<a class="reference internal" href="pymatgen.core.html#pymatgen.core.sites.PeriodicSite.lattice" title="pymatgen.core.sites.PeriodicSite.lattice"><em>lattice</em></a>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">transformation matricies to covert unit vectors to
super lattice vectors</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">matrix_list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.generate_sl_transformations">
<code class="descname">generate_sl_transformations</code><span class="sig-paren">(</span><em>film_area</em>, <em>substrate_area</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.generate_sl_transformations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.generate_sl_transformations" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates transformation sets for film/substrate pair given the
area of the unit cell area for the film and substrate. The
transformation sets map the film and substrate unit cells to super
lattices with a maximum area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>film_area</strong> (<em>int</em>) &#8211; the unit cell area for the film</li>
<li><strong>substrate_area</strong> (<em>int</em>) &#8211; the unit cell area for the substrate</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>a set of transformation_sets defined as:</dt>
<dd><p class="first last">1.) the (i,j) pair corresponding to the integer multiple of
the film area (i) and substrate area (j) that makes the two
equal within tolerance
2.) the transformation matricies for the film to create a
super lattice of area i*film area
3.) the tranformation matricies for the substrate to create
a super lattice of area j*film area</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">transformation_sets</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.generate_slabs">
<code class="descname">generate_slabs</code><span class="sig-paren">(</span><em>film_millers</em>, <em>substrate_millers</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.generate_slabs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.generate_slabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the film/substrate slab combinations for a set of given
miller indicies</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>film_millers</strong> (<em>array</em>) &#8211; all miller indices to generate slabs for
film</li>
<li><strong>substrate_millers</strong> (<em>array</em>) &#8211; all miller indicies to generate slabs
for substrate</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.is_same_vectors">
<code class="descname">is_same_vectors</code><span class="sig-paren">(</span><em>vec_set1</em>, <em>vec_set2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.is_same_vectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.is_same_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two sets of vectors are the same within length and angle
tolerances</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vec_set1</strong> (<em>array[array]</em>) &#8211; an array of two vectors</li>
<li><strong>vec_set2</strong> (<em>array[array]</em>) &#8211; second array of two vectors</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.match_as_dict">
<code class="descname">match_as_dict</code><span class="sig-paren">(</span><em>film_miller</em>, <em>substrate_miller</em>, <em>film_sl_vectors</em>, <em>substrate_sl_vectors</em>, <em>film_vectors</em>, <em>substrate_vectors</em>, <em>match_area</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.match_as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.match_as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns dict which contains ZSL match</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>film_miller</strong> (<em>array</em>) &#8211; </li>
<li><strong>substrate_miller</strong> (<em>array</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.rel_angle">
<code class="descname">rel_angle</code><span class="sig-paren">(</span><em>vec_set1</em>, <em>vec_set2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.rel_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.rel_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the relative angle between two vector sets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vec_set1</strong> (<em>array[array]</em>) &#8211; an array of two vectors</li>
<li><strong>vec_set2</strong> (<em>array[array]</em>) &#8211; second array of two vectors</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.substrate_analyzer.ZSLGenerator.rel_strain">
<code class="descname">rel_strain</code><span class="sig-paren">(</span><em>vec1</em>, <em>vec2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#ZSLGenerator.rel_strain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.ZSLGenerator.rel_strain" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate relative strain between two vectors</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.substrate_analyzer.fast_norm">
<code class="descname">fast_norm</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#fast_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.fast_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Much faster variant of numpy linalg norm</p>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.substrate_analyzer.get_factors">
<code class="descname">get_factors</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#get_factors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.get_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all factors of n</p>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.substrate_analyzer.reduce_vectors">
<code class="descname">reduce_vectors</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#reduce_vectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.reduce_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate independent and unique basis vectors based on the
methodology of Zur and McGill</p>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.substrate_analyzer.vec_angle">
<code class="descname">vec_angle</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#vec_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.vec_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate angle between two vectors</p>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.substrate_analyzer.vec_area">
<code class="descname">vec_area</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/substrate_analyzer.html#vec_area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.substrate_analyzer.vec_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Area of lattice plane defined by two vectors</p>
</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis.thermochemistry">
<span id="pymatgen-analysis-thermochemistry-module"></span><h2>pymatgen.analysis.thermochemistry module<a class="headerlink" href="#module-pymatgen.analysis.thermochemistry" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pymatgen.analysis.thermochemistry.ThermoData">
<em class="property">class </em><code class="descname">ThermoData</code><span class="sig-paren">(</span><em>data_type</em>, <em>cpdname</em>, <em>phaseinfo</em>, <em>formula</em>, <em>value</em>, <em>ref=''</em>, <em>method=''</em>, <em>temp_range=(298</em>, <em>298)</em>, <em>uncertainty=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/thermochemistry.html#ThermoData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.thermochemistry.ThermoData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A object container for an experimental Thermochemical Data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_type</strong> &#8211; The thermochemical data type. Should be one of the
following: fH - Formation enthalpy, S - Entropy,
A, B, C, D, E, F, G, H - variables for use in the various
quations for generating formation enthaplies or Cp at
various temperatures.</li>
<li><strong>cpdname</strong> (<em>str</em>) &#8211; A name for the compound. For example, hematite for
Fe2O3.</li>
<li><strong>phaseinfo</strong> (<em>str</em>) &#8211; Denoting the phase. For example, &#8220;solid&#8221;, &#8220;liquid&#8221;,
&#8220;gas&#8221; or &#8220;tetragonal&#8221;.</li>
<li><strong>formula</strong> (<em>str</em>) &#8211; A proper string formula, e.g., Fe2O3</li>
<li><strong>value</strong> (<em>float</em>) &#8211; The value of the data.</li>
<li><strong>ref</strong> (<em>str</em>) &#8211; A reference, if any, for the data.</li>
<li><strong>method</strong> (<em>str</em>) &#8211; The method by which the data was determined,
if available.</li>
<li><strong>temp_range</strong> (<em>[float, float]</em>) &#8211; Temperature range of validity for the
data in Kelvin. Defaults to 298 K only.</li>
<li><strong>uncertainty</strong> (<em>float</em>) &#8211; An uncertainty for the data, if available.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pymatgen.analysis.thermochemistry.ThermoData.as_dict">
<code class="descname">as_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/thermochemistry.html#ThermoData.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.thermochemistry.ThermoData.as_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="pymatgen.analysis.thermochemistry.ThermoData.from_dict">
<em class="property">classmethod </em><code class="descname">from_dict</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/thermochemistry.html#ThermoData.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.thermochemistry.ThermoData.from_dict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="pymatgen-analysis-transition-state-module">
<h2>pymatgen.analysis.transition_state module<a class="headerlink" href="#pymatgen-analysis-transition-state-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pymatgen.analysis.wulff">
<span id="pymatgen-analysis-wulff-module"></span><h2>pymatgen.analysis.wulff module<a class="headerlink" href="#module-pymatgen.analysis.wulff" title="Permalink to this headline">¶</a></h2>
<p>This module define a WulffShape class to generate the Wulff shape from
a lattice, a list of indices and their corresponding surface energies,
and the total area and volume of the wulff shape,the weighted surface energy,
the anisotropy and shape_factor can also be calculated.
In support of plotting from a given view in terms of miller index.</p>
<p>The lattice is from the conventional unit cell, and (hkil) for hexagonal
lattices.</p>
<p>If you use this code extensively, consider citing the following:</p>
<p>Tran, R.; Xu, Z.; Radhakrishnan, B.; Winston, D.; Persson, K. A.; Ong, S. P.
(2016). Surface energies of elemental crystals. Scientific Data.</p>
<dl class="class">
<dt id="pymatgen.analysis.wulff.WulffFacet">
<em class="property">class </em><code class="descname">WulffFacet</code><span class="sig-paren">(</span><em>normal</em>, <em>e_surf</em>, <em>normal_pt</em>, <em>dual_pt</em>, <em>index</em>, <em>m_ind_orig</em>, <em>miller</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/wulff.html#WulffFacet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.wulff.WulffFacet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Helper container for each Wulff plane.</p>
</dd></dl>

<dl class="class">
<dt id="pymatgen.analysis.wulff.WulffShape">
<em class="property">class </em><code class="descname">WulffShape</code><span class="sig-paren">(</span><em>lattice</em>, <em>miller_list</em>, <em>e_surf_list</em>, <em>symprec=1e-05</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/wulff.html#WulffShape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Generate Wulff Shape from list of miller index and surface energies,
with given conventional unit cell.
surface energy (Jm^2) is the length of normal.</p>
<p>Wulff shape is the convex hull.
Based on:
<a class="reference external" href="http://scipy.github.io/devdocs/generated/scipy.spatial.ConvexHull.html">http://scipy.github.io/devdocs/generated/scipy.spatial.ConvexHull.html</a></p>
<dl class="docutils">
<dt>Process:</dt>
<dd><ol class="first last arabic simple">
<li>get wulff simplices</li>
<li>label with color</li>
<li>get wulff_area and other properties</li>
</ol>
</dd>
</dl>
<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.debug">
<code class="descname">debug</code><span class="sig-paren">(</span><em>bool</em><span class="sig-paren">)</span><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.debug" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.alpha">
<code class="descname">alpha</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.alpha" title="Permalink to this definition">¶</a></dt>
<dt id="pymatgen.analysis.wulff.WulffShape.transparency">
<code class="descname">transparency</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.transparency" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.color_set">
<code class="descname">color_set</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.color_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.grid_off">
<code class="descname">grid_off</code><span class="sig-paren">(</span><em>bool</em><span class="sig-paren">)</span><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.grid_off" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.axis_off">
<code class="descname">axis_off</code><span class="sig-paren">(</span><em>bool</em><span class="sig-paren">)</span><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.axis_off" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.show_area">
<code class="descname">show_area</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.show_area" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.off_color">
<code class="descname">off_color</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.off_color" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">color of facets off wulff</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.structure">
<code class="descname">structure</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.structure" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">Structure object, input conventional unit cell (with H ) from lattice</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.miller_list">
<code class="descname">miller_list</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.miller_list" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">list of input miller index, for hcp in the form of hkil</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.hkl_list">
<code class="descname">hkl_list</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.hkl_list" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">modify hkill to hkl, in the same order with input_miller</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.e_surf_list">
<code class="descname">e_surf_list</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.e_surf_list" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">list of input surface energies, in the same order with input_miller</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.lattice">
<code class="descname">lattice</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.lattice" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">Lattice object, the input lattice for the conventional unit cell</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.facets">
<code class="descname">facets</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.facets" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">[WulffFacet] for all facets considering symm</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.dual_cv_simp">
<code class="descname">dual_cv_simp</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.dual_cv_simp" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">simplices from the dual convex hull (dual_pt)</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.wulff_pt_list">
<code class="descname">wulff_pt_list</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.wulff_pt_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.wulff_cv_simp">
<code class="descname">wulff_cv_simp</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.wulff_cv_simp" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">simplices from the convex hull of wulff_pt_list</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.on_wulff">
<code class="descname">on_wulff</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.on_wulff" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">list for all input_miller, True is on wulff.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.color_area">
<code class="descname">color_area</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.color_area" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">list for all input_miller, total area on wulff, off_wulff = 0.</code></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.miller_area">
<code class="descname">miller_area</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.miller_area" title="Permalink to this definition">¶</a></dt>
<dt>
<code class="descname">($hkl$): area for all input_miller</code></dt>
<dd></dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lattice</strong> &#8211; Lattice object of the conventional unit cell</li>
<li><strong>miller_list</strong> (<em>[(hkl</em>) &#8211; list of hkl or hkil for hcp</li>
<li><strong>e_surf_list</strong> (<em>[float]</em>) &#8211; list of corresponding surface energies</li>
<li><strong>symprec</strong> (<em>float</em>) &#8211; for recp_operation, default is 1e-5.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.anisotropy">
<code class="descname">anisotropy</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.anisotropy" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Returns</em> &#8211; (float) Coefficient of Variation from weighted surface energy
The ideal sphere is 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.area_fraction_dict">
<code class="descname">area_fraction_dict</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.area_fraction_dict" title="Permalink to this definition">¶</a></dt>
<dd><p><a href="#id1"><span class="problematic" id="id2">**</span></a>Returns* &#8211; (dict)* &#8211; {hkl: area_hkl/total area on wulff}</p>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.wulff.WulffShape.get_plot">
<code class="descname">get_plot</code><span class="sig-paren">(</span><em>color_set='PuBu'</em>, <em>grid_off=True</em>, <em>axis_off=True</em>, <em>show_area=False</em>, <em>alpha=1</em>, <em>off_color='red'</em>, <em>direction=None</em>, <em>bar_pos=(0.75</em>, <em>0.15</em>, <em>0.05</em>, <em>0.65)</em>, <em>bar_on=False</em>, <em>legend_on=True</em>, <em>aspect_ratio=(8</em>, <em>8)</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/wulff.html#WulffShape.get_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.get_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Wulff shape plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>color_set</strong> &#8211; default is &#8216;PuBu&#8217;</li>
<li><strong>grid_off</strong> (<em>bool</em>) &#8211; default is True</li>
<li><strong>axis_off</strong> (<em>bool</em>) &#8211; default is Ture</li>
<li><strong>show_area</strong> (<em>bool</em>) &#8211; default is False</li>
<li><strong>alpha</strong> (<em>float</em>) &#8211; chosen from 0 to 1 (float), default is 1</li>
<li><strong>off_color</strong> &#8211; color_legend for off_wulff facets on show_area legend</li>
<li><strong>direction</strong> &#8211; default is (1, 1, 1)</li>
<li><strong>bar_pos</strong> &#8211; default is [0.75, 0.15, 0.05, 0.65]</li>
<li><strong>bar_on</strong> (<em>bool</em>) &#8211; default is False</li>
<li><strong>legend_on</strong> (<em>bool</em>) &#8211; default is True</li>
<li><strong>aspect_ratio</strong> &#8211; default is (8, 8)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(matplotlib.pyplot)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.miller_area_dict">
<code class="descname">miller_area_dict</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.miller_area_dict" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Returns {hkl</em> &#8211; area_hkl on wulff}</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.miller_energy_dict">
<code class="descname">miller_energy_dict</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.miller_energy_dict" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Returns {hkl</em> &#8211; surface energy_hkl}</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.shape_factor">
<code class="descname">shape_factor</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.shape_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>This is useful for determining the critical nucleus size.
A large shape factor indicates great anisotropy.
See Ballufi, R. W., Allen, S. M. &amp; Carter, W. C. Kinetics</p>
<blockquote>
<div>of Materials. (John Wiley &amp; Sons, 2005), p.461</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">(float) Shape factor.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pymatgen.analysis.wulff.WulffShape.show">
<code class="descname">show</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/wulff.html#WulffShape.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the Wulff plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>*args</strong> &#8211; Passed to get_plot.</li>
<li><strong>**kwargs</strong> &#8211; Passed to get_plot.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.surface_area">
<code class="descname">surface_area</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.surface_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Total surface area of Wulff shape.</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.volume">
<code class="descname">volume</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the Wulff shape</p>
</dd></dl>

<dl class="attribute">
<dt id="pymatgen.analysis.wulff.WulffShape.weighted_surface_energy">
<code class="descname">weighted_surface_energy</code><a class="headerlink" href="#pymatgen.analysis.wulff.WulffShape.weighted_surface_energy" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Returns</em> &#8211; sum(surface_energy_hkl * area_hkl)/ sum(area_hkl)</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.wulff.get_tri_area">
<code class="descname">get_tri_area</code><span class="sig-paren">(</span><em>pts</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/wulff.html#get_tri_area"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.wulff.get_tri_area" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list of coords for 3 points,
Compute the area of this triangle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pts</strong> &#8211; [a, b, c] three points</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pymatgen.analysis.wulff.hkl_tuple_to_str">
<code class="descname">hkl_tuple_to_str</code><span class="sig-paren">(</span><em>hkl</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/analysis/wulff.html#hkl_tuple_to_str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.analysis.wulff.hkl_tuple_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare for display on plots
&#8220;(hkl)&#8221; for surfaces
Agrs:</p>
<blockquote>
<div>hkl: in the form of [h, k, l] or (h, k, l)</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-pymatgen.analysis">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pymatgen.analysis" title="Permalink to this headline">¶</a></h2>
<p>This package is an overarching package for modules performing various analyses
of materials data.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pymatgen.analysis package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.bond_valence">pymatgen.analysis.bond_valence module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.diffusion_analyzer">pymatgen.analysis.diffusion_analyzer module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.energy_models">pymatgen.analysis.energy_models module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.eos">pymatgen.analysis.eos module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.ewald">pymatgen.analysis.ewald module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.molecule_matcher">pymatgen.analysis.molecule_matcher module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.molecule_structure_comparator">pymatgen.analysis.molecule_structure_comparator module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.nmr">pymatgen.analysis.nmr module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.piezo">pymatgen.analysis.piezo module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.reaction_calculator">pymatgen.analysis.reaction_calculator module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.structure_analyzer">pymatgen.analysis.structure_analyzer module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.structure_matcher">pymatgen.analysis.structure_matcher module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.substrate_analyzer">pymatgen.analysis.substrate_analyzer module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.thermochemistry">pymatgen.analysis.thermochemistry module</a></li>
<li><a class="reference internal" href="#pymatgen-analysis-transition-state-module">pymatgen.analysis.transition_state module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis.wulff">pymatgen.analysis.wulff module</a></li>
<li><a class="reference internal" href="#module-pymatgen.analysis">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/pymatgen.analysis.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">pymatgen 4.2.1 documentation</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>